(function() {
  window.Ably = {};
  for(var D = {disconnected:{statusCode:408, code:80003, reason:"Connection to server temporarily unavailable"}, suspended:{statusCode:408, code:80002, reason:"Connection to server unavailable"}, failed:{statusCode:408, code:8E4, reason:"Connection failed or disconnected by server"}, unknownConnectionErr:{statusCode:500, code:50002, reason:"Internal connection error"}, unknownChannelErr:{statusCode:500, code:50001, reason:"Internal channel error"}}, I = function(a, c, b) {
    function e() {
    }
    e.prototype = c.prototype;
    a.prototype = new e;
    if(b) {
      for(var g in b) {
        a.prototype[g] = b[g]
      }
    }
  }, ea = [], l = 0;256 > l;l++) {
    ea[l] = (15 < l ? "" : "0") + l.toString(16)
  }
  var K = function(a, c) {
    a instanceof Array ? (this.buffer = a, this.offset = c || 0) : (this.buffer = this.buffer || Array(8), this.offset = 0, this.setValue.apply(this, arguments))
  };
  K.MAX_INT = Math.pow(2, 53);
  K.MIN_INT = -Math.pow(2, 53);
  K.prototype = {_2scomp:function() {
    for(var a = this.buffer, c = this.offset, b = 1, e = c + 7;e >= c;e--) {
      b = (a[e] ^ 255) + b, a[e] = b & 255, b >>= 8
    }
  }, setValue:function(a, c) {
    var b = !1;
    if(1 == arguments.length) {
      if("number" == typeof a) {
        b = 0 > a;
        a = Math.abs(a);
        c = a % 4294967296;
        a /= 4294967296;
        if(4294967296 < a) {
          throw new RangeError(a + " is outside Int64 range");
        }
        a |= 0
      }else {
        if("string" == typeof a) {
          a = (a + "").replace(/^0x/, ""), c = a.substr(-8), a = 8 < a.length ? a.substr(0, a.length - 8) : "", a = parseInt(a, 16), c = parseInt(c, 16)
        }else {
          throw Error(a + " must be a Number or String");
        }
      }
    }
    for(var e = this.buffer, g = this.offset, f = 7;0 <= f;f--) {
      e[g + f] = c & 255, c = 4 == f ? a : c >>> 8
    }
    b && this._2scomp()
  }, toNumber:function(a) {
    for(var c = this.buffer, b = this.offset, e = c[0] & 128, g = 0, f = 1, t = 7, d = 1;0 <= t;t--, d *= 256) {
      var m = c[b + t];
      e && (m = (m ^ 255) + f, f = m >> 8, m &= 255);
      g += m * d
    }
    return!a && g >= K.MAX_INT ? e ? -Infinity : Infinity : e ? -g : g
  }, valueOf:function() {
    return this.toNumber(!1)
  }, toString:function(a) {
    return this.valueOf().toString(a || 10)
  }, toOctetString:function(a) {
    for(var c = Array(8), b = this.buffer, e = this.offset, g = 0;8 > g;g++) {
      c[g] = ea[b[e + g]]
    }
    return c.join(a || "")
  }, inspect:function() {
    return"[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]"
  }};
  var d = {Version:"0.8.0", Type:{STOP:0, VOID:1, BOOL:2, BYTE:3, I08:3, DOUBLE:4, I16:6, I32:8, I64:10, STRING:11, UTF7:11, STRUCT:12, MAP:13, SET:14, LIST:15, UTF8:16, UTF16:17}, MessageType:{CALL:1, REPLY:2, EXCEPTION:3}, objectLength:function(a) {
    var c = 0, b;
    for(b in a) {
      a.hasOwnProperty(b) && c++
    }
    return c
  }, inherits:function(a, c) {
    function b() {
    }
    b.prototype = c.prototype;
    a.prototype = new b
  }, TException:function(a) {
    this.message = a
  }};
  d.inherits(d.TException, Error);
  d.TException.prototype.name = "TException";
  d.TApplicationExceptionType = {UNKNOWN:0, UNKNOWN_METHOD:1, INVALID_MESSAGE_TYPE:2, WRONG_METHOD_NAME:3, BAD_SEQUENCE_ID:4, MISSING_RESULT:5, INTERNAL_ERROR:6, PROTOCOL_ERROR:7};
  d.TApplicationException = function(a, c) {
    this.message = a;
    this.code = null === c ? 0 : c
  };
  d.inherits(d.TApplicationException, d.TException);
  d.TApplicationException.prototype.name = "TApplicationException";
  d.TApplicationException.prototype.read = function(a) {
    for(;;) {
      var c = a.readFieldBegin();
      if(c.ftype == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          c.ftype == d.Type.STRING ? (c = a.readString(), this.message = c.value) : a.skip(c.ftype);
          break;
        case 2:
          c.ftype == d.Type.I32 ? (c = a.readI32(), this.code = c.value) : a.skip(c.ftype);
          break;
        default:
          a.skip(c.ftype)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  d.TApplicationException.prototype.write = function(a) {
    a.writeStructBegin("TApplicationException");
    this.message && (a.writeFieldBegin("message", d.Type.STRING, 1), a.writeString(this.getMessage()), a.writeFieldEnd());
    this.code && (a.writeFieldBegin("type", d.Type.I32, 2), a.writeI32(this.code), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  d.TApplicationException.prototype.getCode = function() {
    return this.code
  };
  d.TApplicationException.prototype.getMessage = function() {
    return this.message
  };
  d.TXHRTransport = function(a) {
    this.url = a;
    this.rpos = this.wpos = 0;
    this.recv_buf = this.send_buf = ""
  };
  d.TXHRTransport.prototype = {getXmlHttpRequestObject:function() {
    try {
      return new XMLHttpRequest
    }catch(a) {
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP")
    }catch(c) {
    }
    try {
      return new ActiveXObject("Microsoft.XMLHTTP")
    }catch(b) {
    }
    throw"Your browser doesn't support the XmlHttpRequest object.";
  }, flush:function(a) {
    if(a || void 0 === this.url || "" === this.url) {
      return this.send_buf
    }
    a = this.getXmlHttpRequestObject();
    a.overrideMimeType && a.overrideMimeType("application/json");
    a.open("POST", this.url, !1);
    a.send(this.send_buf);
    if(4 != a.readyState) {
      throw"encountered an unknown ajax ready state: " + a.readyState;
    }
    if(200 != a.status) {
      throw"encountered a unknown request status: " + a.status;
    }
    this.recv_buf = a.responseText;
    this.wpos = this.recv_buf_sz = this.recv_buf.length;
    this.rpos = 0
  }, jqRequest:function(a, c, b, e) {
    if("undefined" === typeof jQuery || "undefined" === typeof jQuery.Deferred) {
      throw"Thrift.js requires jQuery 1.5+ to use asynchronous requests";
    }
    var g = jQuery.Deferred(), f = jQuery._Deferred(), t = g.promise();
    t.success = t.done;
    t.error = t.fail;
    t.complete = f.done;
    c = jQuery.ajax({url:this.url, data:c, type:"POST", cache:!1, dataType:"text", context:this, success:this.jqResponse, error:function(b, c, f) {
      g.rejectWith(a, jQuery.merge([f], b.tArgs))
    }, complete:function(b, c) {
      f.resolveWith(a, [b, c])
    }});
    g.done(jQuery.makeArray(b).pop());
    c.tArgs = b;
    c.tClient = a;
    c.tRecvFn = e;
    c.tDfd = g;
    return t
  }, jqResponse:function(a, c, b) {
    this.setRecvBuffer(a);
    try {
      var e = b.tRecvFn.call(b.tClient);
      b.tDfd.resolveWith(b, jQuery.merge([e], b.tArgs))
    }catch(g) {
      b.tDfd.rejectWith(b, jQuery.merge([g], b.tArgs))
    }
  }, setRecvBuffer:function(a) {
    this.recv_buf = a;
    this.wpos = this.recv_buf_sz = this.recv_buf.length;
    this.rpos = 0
  }, isOpen:function() {
    return!0
  }, open:function() {
  }, close:function() {
  }, read:function(a) {
    var c = this.wpos - this.rpos;
    if(0 === c) {
      return""
    }
    var b = a;
    c < a && (b = c);
    a = this.read_buf.substr(this.rpos, b);
    this.rpos += b;
    return a
  }, readAll:function() {
    return this.recv_buf
  }, write:function(a) {
    this.send_buf = a
  }, getSendBuffer:function() {
    return this.send_buf
  }};
  d.TStringTransport = function(a, c) {
    this.send_buf = "";
    this.recv_buf = a || "";
    this.onFlush = c
  };
  d.TStringTransport.prototype = {flush:function() {
    if(this.onFlush) {
      this.onFlush(this.send_buf)
    }
  }, isOpen:function() {
    return!0
  }, open:function() {
  }, close:function() {
  }, read:function(a) {
    return this.recv_buf
  }, readAll:function() {
    return this.recv_buf
  }, write:function(a) {
    this.send_buf = a
  }};
  d.Protocol = function(a) {
    this.transport = a
  };
  d.Protocol.Type = {};
  d.Protocol.Type[d.Type.BOOL] = '"tf"';
  d.Protocol.Type[d.Type.BYTE] = '"i8"';
  d.Protocol.Type[d.Type.I16] = '"i16"';
  d.Protocol.Type[d.Type.I32] = '"i32"';
  d.Protocol.Type[d.Type.I64] = '"i64"';
  d.Protocol.Type[d.Type.DOUBLE] = '"dbl"';
  d.Protocol.Type[d.Type.STRUCT] = '"rec"';
  d.Protocol.Type[d.Type.STRING] = '"str"';
  d.Protocol.Type[d.Type.MAP] = '"map"';
  d.Protocol.Type[d.Type.LIST] = '"lst"';
  d.Protocol.Type[d.Type.SET] = '"set"';
  d.Protocol.RType = {};
  d.Protocol.RType.tf = d.Type.BOOL;
  d.Protocol.RType.i8 = d.Type.BYTE;
  d.Protocol.RType.i16 = d.Type.I16;
  d.Protocol.RType.i32 = d.Type.I32;
  d.Protocol.RType.i64 = d.Type.I64;
  d.Protocol.RType.dbl = d.Type.DOUBLE;
  d.Protocol.RType.rec = d.Type.STRUCT;
  d.Protocol.RType.str = d.Type.STRING;
  d.Protocol.RType.map = d.Type.MAP;
  d.Protocol.RType.lst = d.Type.LIST;
  d.Protocol.RType.set = d.Type.SET;
  d.Protocol.Version = 1;
  d.Protocol.prototype = {getTransport:function() {
    return this.transport
  }, writeMessageBegin:function(a, c, b) {
    this.tstack = [];
    this.tpos = [];
    this.tstack.push([d.Protocol.Version, '"' + a + '"', c, b])
  }, writeMessageEnd:function() {
    var a = this.tstack.pop();
    this.wobj = this.tstack.pop();
    this.wobj.push(a);
    this.wbuf = "[" + this.wobj.join(",") + "]";
    this.transport.write(this.wbuf)
  }, writeStructBegin:function(a) {
    this.tpos.push(this.tstack.length);
    this.tstack.push({})
  }, writeStructEnd:function() {
    var a = this.tpos.pop(), c = this.tstack[a], b = "{", e = !0, g;
    for(g in c) {
      e ? e = !1 : b += ",", b += g + ":" + c[g]
    }
    this.tstack[a] = b + "}"
  }, writeFieldBegin:function(a, c, b) {
    this.tpos.push(this.tstack.length);
    this.tstack.push({fieldId:'"' + b + '"', fieldType:d.Protocol.Type[c]})
  }, writeFieldEnd:function() {
    var a = this.tstack.pop(), c = this.tstack.pop();
    this.tstack[this.tstack.length - 1][c.fieldId] = "{" + c.fieldType + ":" + a + "}";
    this.tpos.pop()
  }, writeFieldStop:function() {
  }, writeMapBegin:function(a, c, b) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([d.Protocol.Type[a], d.Protocol.Type[c], 0])
  }, writeMapEnd:function() {
    var a = this.tpos.pop();
    if(a != this.tstack.length) {
      0 !== (this.tstack.length - a - 1) % 2 && this.tstack.push("");
      this.tstack[a][this.tstack[a].length - 1] = (this.tstack.length - a - 1) / 2;
      for(var c = "}", b = !0;this.tstack.length > a + 1;) {
        var e = this.tstack.pop(), g = this.tstack.pop();
        b ? b = !1 : c = "," + c;
        isNaN(g) || (g = '"' + g + '"');
        c = g + ":" + e + c
      }
      this.tstack[a].push("{" + c);
      this.tstack[a] = "[" + this.tstack[a].join(",") + "]"
    }
  }, writeListBegin:function(a, c) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([d.Protocol.Type[a], c])
  }, writeListEnd:function() {
    for(var a = this.tpos.pop();this.tstack.length > a + 1;) {
      var c = this.tstack[a + 1];
      this.tstack.splice(a + 1, 1);
      this.tstack[a].push(c)
    }
    this.tstack[a] = "[" + this.tstack[a].join(",") + "]"
  }, writeSetBegin:function(a, c) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([d.Protocol.Type[a], c])
  }, writeSetEnd:function() {
    for(var a = this.tpos.pop();this.tstack.length > a + 1;) {
      var c = this.tstack[a + 1];
      this.tstack.splice(a + 1, 1);
      this.tstack[a].push(c)
    }
    this.tstack[a] = "[" + this.tstack[a].join(",") + "]"
  }, writeBool:function(a) {
    this.tstack.push(a ? 1 : 0)
  }, writeByte:function(a) {
    this.tstack.push(a)
  }, writeI16:function(a) {
    this.tstack.push(a)
  }, writeI32:function(a) {
    this.tstack.push(a)
  }, writeI64:function(a) {
    this.tstack.push(a)
  }, writeDouble:function(a) {
    this.tstack.push(a)
  }, writeString:function(a) {
    if(null === a) {
      this.tstack.push(null)
    }else {
      for(var c = "", b = 0;b < a.length;b++) {
        var e = a.charAt(b), c = '"' === e ? c + '\\"' : "\\" === e ? c + "\\\\" : "\b" === e ? c + "\\b" : "\f" === e ? c + "\\f" : "\n" === e ? c + "\\n" : "\r" === e ? c + "\\r" : "\t" === e ? c + "\\t" : c + e
      }
      this.tstack.push('"' + c + '"')
    }
  }, writeBinary:function(a) {
    this.writeString(a)
  }, readMessageBegin:function(a, c, b) {
    this.rstack = [];
    this.rpos = [];
    this.robj = "undefined" !== typeof jQuery ? jQuery.parseJSON(this.transport.readAll()) : eval(this.transport.readAll());
    a = {};
    c = this.robj.shift();
    if(c != d.Protocol.Version) {
      throw"Wrong thrift protocol version: " + c;
    }
    a.fname = this.robj.shift();
    a.mtype = this.robj.shift();
    a.rseqid = this.robj.shift();
    this.rstack.push(this.robj.shift());
    return a
  }, readMessageEnd:function() {
  }, readStructBegin:function(a) {
    this.rstack[this.rstack.length - 1] instanceof Array && this.rstack.push(this.rstack[this.rstack.length - 1].shift());
    return{fname:""}
  }, readStructEnd:function() {
    this.rstack[this.rstack.length - 2] instanceof Array && this.rstack.pop()
  }, readFieldBegin:function() {
    var a = {}, c = -1, b = d.Type.STOP, e;
    for(e in this.rstack[this.rstack.length - 1]) {
      if(null !== e) {
        c = parseInt(e, 10);
        this.rpos.push(this.rstack.length);
        e = this.rstack[this.rstack.length - 1][c];
        delete this.rstack[this.rstack.length - 1][c];
        this.rstack.push(e);
        break
      }
    }
    if(-1 != c) {
      for(var g in this.rstack[this.rstack.length - 1]) {
        null !== d.Protocol.RType[g] && (b = d.Protocol.RType[g], this.rstack[this.rstack.length - 1] = this.rstack[this.rstack.length - 1][g])
      }
    }
    a.fname = "";
    a.ftype = b;
    a.fid = c;
    return a
  }, readFieldEnd:function() {
    for(var a = this.rpos.pop();this.rstack.length > a;) {
      this.rstack.pop()
    }
  }, readMapBegin:function(a, c, b) {
    a = this.rstack.pop();
    c = {};
    c.ktype = d.Protocol.RType[a.shift()];
    c.vtype = d.Protocol.RType[a.shift()];
    c.size = a.shift();
    this.rpos.push(this.rstack.length);
    this.rstack.push(a.shift());
    return c
  }, readMapEnd:function() {
    this.readFieldEnd()
  }, readListBegin:function(a, c) {
    var b = this.rstack[this.rstack.length - 1], e = {};
    e.etype = d.Protocol.RType[b.shift()];
    e.size = b.shift();
    this.rpos.push(this.rstack.length);
    this.rstack.push(b);
    return e
  }, readListEnd:function() {
    this.readFieldEnd()
  }, readSetBegin:function(a, c) {
    return this.readListBegin(a, c)
  }, readSetEnd:function() {
    return this.readListEnd()
  }, readBool:function() {
    var a = this.readI32();
    a.value = null !== a && "1" == a.value ? !0 : !1;
    return a
  }, readByte:function() {
    return this.readI32()
  }, readI16:function() {
    return this.readI32()
  }, readI32:function(a) {
    void 0 === a && (a = this.rstack[this.rstack.length - 1]);
    var c = {};
    if(a instanceof Array) {
      c.value = 0 === a.length ? void 0 : a.shift()
    }else {
      if(a instanceof Object) {
        for(var b in a) {
          if(null !== b) {
            this.rstack.push(a[b]);
            delete a[b];
            c.value = b;
            break
          }
        }
      }else {
        c.value = a, this.rstack.pop()
      }
    }
    return c
  }, readI64:function() {
    return this.readI32()
  }, readDouble:function() {
    return this.readI32()
  }, readString:function() {
    return this.readI32()
  }, readBinary:function() {
    return this.readString()
  }, skip:function(a) {
    throw"skip not supported yet";
  }};
  d.TJSONProtocol = function(a) {
    this.transport = a;
    this.reset()
  };
  d.TJSONProtocol.Type = {};
  d.TJSONProtocol.Type[d.Type.BOOL] = "tf";
  d.TJSONProtocol.Type[d.Type.BYTE] = "i8";
  d.TJSONProtocol.Type[d.Type.I16] = "i16";
  d.TJSONProtocol.Type[d.Type.I32] = "i32";
  d.TJSONProtocol.Type[d.Type.I64] = "i64";
  d.TJSONProtocol.Type[d.Type.DOUBLE] = "dbl";
  d.TJSONProtocol.Type[d.Type.STRUCT] = "rec";
  d.TJSONProtocol.Type[d.Type.STRING] = "str";
  d.TJSONProtocol.Type[d.Type.MAP] = "map";
  d.TJSONProtocol.Type[d.Type.LIST] = "lst";
  d.TJSONProtocol.Type[d.Type.SET] = "set";
  d.TJSONProtocol.getValueFromScope = function(a) {
    var c = a.listvalue;
    return c ? c.shift() : a.value
  };
  d.TJSONProtocol.getScopeFromScope = function(a) {
    var c = a.listvalue;
    c && (a = {value:c.shift()});
    return a
  };
  d.TJSONProtocol.prototype = {reset:function() {
    this.elementStack = []
  }, writeMessageBegin:function(a, c, b) {
    throw Error("TJSONProtocol: Message not supported");
  }, writeMessageEnd:function() {
  }, writeStructBegin:function(a) {
    this.elementStack.unshift({})
  }, writeStructEnd:function() {
    var a = this.elementStack.shift();
    0 == this.elementStack.length ? this.transport.write(JSON.stringify(a)) : this.elementStack[0].value.push(a)
  }, writeFieldBegin:function(a, c, b) {
    this.elementStack.unshift({name:a, fieldType:d.TJSONProtocol.Type[c], fieldId:b, value:[]})
  }, writeFieldEnd:function() {
    var a = this.elementStack.shift(), c = {};
    c[a.fieldType] = a.value[0];
    this.elementStack[0][a.fieldId] = c
  }, writeFieldStop:function() {
  }, writeMapBegin:function(a, c, b) {
    this.elementStack.unshift({value:[d.TJSONProtocol.Type[a], d.TJSONProtocol.Type[c], b]})
  }, writeMapEnd:function() {
    var a = this.elementStack.shift();
    this.elementStack[0].value.push(a.value)
  }, writeListBegin:function(a, c) {
    this.elementStack.unshift({name:name, value:[d.TJSONProtocol.Type[a], c]})
  }, writeListEnd:function() {
    var a = this.elementStack.shift();
    this.elementStack[0].value.push(a.value)
  }, writeSetBegin:function(a, c) {
    this.elementStack.unshift({name:name, value:[d.TJSONProtocol.Type[a], c]})
  }, writeSetEnd:function() {
    var a = this.elementStack.shift();
    this.elementStack[0].value.push(a.value)
  }, writeBool:function(a) {
    this.elementStack[0].value.push(a ? 1 : 0)
  }, writeByte:function(a) {
    this.elementStack[0].value.push(a)
  }, writeI16:function(a) {
    this.elementStack[0].value.push(a)
  }, writeI32:function(a) {
    this.elementStack[0].value.push(a)
  }, writeI64:function(a) {
    this.elementStack[0].value.push(a)
  }, writeDouble:function(a) {
    this.elementStack[0].value.push(a)
  }, writeString:function(a) {
    this.elementStack[0].value.push(a)
  }, writeBinary:function(a) {
    this.elementStack[0].value.push(a)
  }, readMessageBegin:function(a, c, b) {
    throw Error("TJSONProtocol: Message not supported");
  }, readMessageEnd:function() {
  }, readStructBegin:function(a) {
    a = 0 == this.elementStack.length ? JSON.parse(this.transport.readAll()) : d.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    var c = [], b;
    for(b in a) {
      c.push(b)
    }
    this.elementStack.unshift({fields:c, value:a});
    return{fname:""}
  }, readStructEnd:function() {
    this.elementStack.shift()
  }, readFieldBegin:function() {
    var a = this.elementStack[0], c = d.TJSONProtocol.getValueFromScope(a), a = a.fields.shift();
    if(!a) {
      return{fname:"", ftype:d.Type.STOP}
    }
    var c = c[a], b;
    for(b in c) {
      return this.elementStack.unshift({value:c[b]}), {fname:"", fid:Number(a), ftype:d.Protocol.RType[b]}
    }
    throw Error("TJSONProtocol: parse error reading field value");
  }, readFieldEnd:function() {
    this.elementStack.shift()
  }, readMapBegin:function(a, c, b) {
    a = d.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    c = {ktype:d.Protocol.RType[a.shift()], vtype:d.Protocol.RType[a.shift()], size:a.shift()};
    this.elementStack.unshift({listvalue:a});
    return c
  }, readMapEnd:function() {
    this.elementStack.shift()
  }, readListBegin:function(a, c) {
    var b = d.TJSONProtocol.getValueFromScope(this.elementStack[0]), e = {etype:d.Protocol.RType[b.shift()], size:b.shift()};
    this.elementStack.unshift({listvalue:b});
    return e
  }, readListEnd:function() {
    this.elementStack.shift()
  }, readSetBegin:function(a, c) {
    var b = d.TJSONProtocol.getValueFromScope(this.elementStack[0]), e = {etype:d.Protocol.RType[b.shift()], size:b.shift()};
    this.elementStack.unshift({listvalue:b});
    return e
  }, readSetEnd:function() {
    this.elementStack.shift()
  }, readBool:function() {
    return!!d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readByte:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readI16:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readI32:function(a) {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readI64:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readDouble:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readString:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readBinary:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, flush:function() {
    this.transport.flush()
  }};
  var X = {encode:function(a, c, b) {
    for(var e = b, g = 0;g < a.length;g++) {
      var f = a.charCodeAt(g);
      128 > f ? c.setInt8(e++, f) : (127 < f && 2048 > f ? c.setInt8(e++, f >> 6 | 192) : (c.setInt8(e++, f >> 12 | 224), c.setInt8(e++, f >> 6 & 63 | 128)), c.setInt8(e++, f & 63 | 128))
    }
    return e - b
  }, decode:function(a, c, b) {
    var e = "", g = c;
    b += c;
    for(c = c1 = c2 = 0;g < b;) {
      c = a.getInt8(g++), 128 > c ? e += String.fromCharCode(c) : 191 < c && 224 > c ? (c2 = a.getInt8(g++), e += String.fromCharCode((c & 31) << 6 | c2 & 63)) : (c2 = a.getInt8(g++), c3 = a.getInt8(g++), e += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63))
    }
    return e
  }}, A = function(a) {
    this.offset = 0;
    if(this.length = a) {
      a = this.buf = new ArrayBuffer(a), this.view = new DataView(a)
    }
  };
  A.prototype = {getArray:function() {
    this.array || (this.array = new Uint8Array(this.buf, this.offset, this.length));
    return this.array
  }, slice:function(a, c) {
    a = a || 0;
    c = c || this.length;
    var b = new A, e = b.length = c - a, g = b.offset = this.offset + a, f = b.buf = this.buf;
    b.view = new DataView(f, g, e);
    return b
  }, getInt8:function(a) {
    return this.view.getInt8(a)
  }, getInt16:function(a) {
    return this.view.getInt16(a, !1)
  }, getInt32:function(a) {
    return this.view.getInt32(a, !1)
  }, getInt64:function(a) {
    var c = this.view.getInt32(a, !1);
    a = this.view.getUint32(a + 4, !1);
    return new K(c, a)
  }, getFloat64:function(a) {
    return this.view.getFloat64(a, !1)
  }, getUtf8String:function(a, c) {
    return X.decode(this.view, a, c)
  }, setInt8:function(a, c) {
    this.view.setInt8(a, c)
  }, setInt16:function(a, c) {
    this.view.setInt16(a, c, !1)
  }, setInt32:function(a, c) {
    this.view.setInt32(a, c, !1)
  }, setInt64:function(a, c) {
    this.getArray().set(c.buffer, a)
  }, setFloat64:function(a, c) {
    this.view.setFloat64(a, c, !1)
  }, setBuffer:function(a, c) {
    this.getArray().set(c.getArray(), a)
  }, setUtf8String:function(a, c) {
    return X.encode(c, this.view, a)
  }, inspect:function() {
    for(var a = "length: " + this.length + "\n", c = 0;c < this.length;) {
      for(var b = 0;c < this.length && 32 > b;b++) {
        a += this.view.getInt8(c++).toString(16) + " "
      }
      a += "\n"
    }
    return a
  }};
  l = d.CheckedBuffer = function(a) {
    A.call(this, a)
  };
  I(l, A, {grow:function(a) {
    a = this.length + Math.max(a || 0, 0.41 * this.length);
    var c = getArray();
    this.buf = new ArrayBuffer(a);
    this.view = new DataView(this.buf);
    this.getArray().set(c);
    this.offset = 0;
    this.length = a
  }, checkAvailable:function(a, c) {
    a + c >= this.length && this.grow(c)
  }, setInt8:function(a, c) {
    this.checkAvailable(1);
    this.view.setInt8(a, c)
  }, setInt16:function(a, c) {
    this.checkAvailable(2);
    this.view.setInt16(a, c, !1)
  }, setInt32:function(a, c) {
    this.checkAvailable(4);
    this.view.setInt32(a, c, !1)
  }, setInt64:function(a, c) {
    this.checkAvailable(8);
    this.getArray().set(c.buffer, a)
  }, setFloat64:function(a, c) {
    this.checkAvailable(8);
    this.view.setFloat64(a, c, !1)
  }, setBuffer:function(a, c) {
    this.checkAvailable(c.length);
    this.getArray().set(c.getArray(), a)
  }, setUtf8String:function(a, c) {
    for(;;) {
      try {
        return X.encode(c, this.view, a)
      }catch(b) {
        this.grow()
      }
    }
  }});
  var x = d.Type, Y = function(a, c) {
    Error.call(this, c);
    this.name = "TProtocolException";
    this.type = a
  };
  I(Y, Error);
  l = d.TBinaryProtocol = function(a, c, b) {
    this.trans = a;
    this.strictRead = void 0 !== c ? c : !1;
    this.strictWrite = void 0 !== b ? b : !0
  };
  l.prototype.flush = function() {
    return this.trans.flush()
  };
  l.prototype.writeMessageBegin = function(a, c, b) {
    this.strictWrite ? (this.writeI32(-2147418112 | c), this.writeString(a)) : (this.writeString(a), this.writeByte(c));
    this.writeI32(b)
  };
  l.prototype.writeMessageEnd = function() {
  };
  l.prototype.writeStructBegin = function(a) {
  };
  l.prototype.writeStructEnd = function() {
  };
  l.prototype.writeFieldBegin = function(a, c, b) {
    this.writeByte(c);
    this.writeI16(b)
  };
  l.prototype.writeFieldEnd = function() {
  };
  l.prototype.writeFieldStop = function() {
    this.writeByte(x.STOP)
  };
  l.prototype.writeMapBegin = function(a, c, b) {
    this.writeByte(a);
    this.writeByte(c);
    this.writeI32(b)
  };
  l.prototype.writeMapEnd = function() {
  };
  l.prototype.writeListBegin = function(a, c) {
    this.writeByte(a);
    this.writeI32(c)
  };
  l.prototype.writeListEnd = function() {
  };
  l.prototype.writeSetBegin = function(a, c) {
    this.writeByte(a);
    this.writeI32(c)
  };
  l.prototype.writeSetEnd = function() {
  };
  l.prototype.writeBool = function(a) {
    this.writeByte(a ? 1 : 0)
  };
  l.prototype.writeByte = function(a) {
    this.trans.writeByte(a)
  };
  l.prototype.writeI16 = function(a) {
    this.trans.writeI16(a)
  };
  l.prototype.writeI32 = function(a) {
    this.trans.writeI32(a)
  };
  l.prototype.writeI64 = function(a) {
    a.buffer ? this.trans.writeI64(a) : this.trans.writeI64(new K(a))
  };
  l.prototype.writeDouble = function(a) {
    this.trans.writeDouble(a)
  };
  l.prototype.writeString = function(a) {
    this.trans.writeWithLength(a)
  };
  l.prototype.writeBinary = function(a) {
    this.trans.writeWithLength(a)
  };
  l.prototype.readMessageBegin = function() {
    var a = this.readI32(), c, b;
    if(0 > a) {
      c = a & -65536;
      if(-2147418112 != c) {
        throw console.log("BAD: " + c), Y(4, "Bad version in readMessageBegin: " + a);
      }
      a &= 255;
      c = this.readString()
    }else {
      if(this.strictRead) {
        throw Y(4, "No protocol version header");
      }
      c = this.trans.read(a);
      a = this.readByte()
    }
    b = this.readI32();
    return{fname:c, mtype:a, rseqid:b}
  };
  l.prototype.readMessageEnd = function() {
  };
  l.prototype.readStructBegin = function() {
    return{fname:""}
  };
  l.prototype.readStructEnd = function() {
  };
  l.prototype.readFieldBegin = function() {
    var a = this.readByte();
    if(a == x.STOP) {
      return{fname:null, ftype:a, fid:0}
    }
    var c = this.readI16();
    return{fname:null, ftype:a, fid:c}
  };
  l.prototype.readFieldEnd = function() {
  };
  l.prototype.readMapBegin = function() {
    var a = this.readByte(), c = this.readByte(), b = this.readI32();
    return{ktype:a, vtype:c, size:b}
  };
  l.prototype.readMapEnd = function() {
  };
  l.prototype.readListBegin = function() {
    var a = this.readByte(), c = this.readI32();
    return{etype:a, size:c}
  };
  l.prototype.readListEnd = function() {
  };
  l.prototype.readSetBegin = function() {
    var a = this.readByte(), c = this.readI32();
    return{etype:a, size:c}
  };
  l.prototype.readSetEnd = function() {
  };
  l.prototype.readBool = function() {
    return 0 == this.readByte() ? !1 : !0
  };
  l.prototype.readByte = function() {
    return this.trans.readByte()
  };
  l.prototype.readI16 = function() {
    return this.trans.readI16()
  };
  l.prototype.readI32 = function() {
    return this.trans.readI32()
  };
  l.prototype.readI64 = function() {
    return this.trans.readI64()
  };
  l.prototype.readDouble = function() {
    return this.trans.readDouble()
  };
  l.prototype.readBinary = function() {
    var a = this.readI32();
    return this.trans.read(a)
  };
  l.prototype.readString = function() {
    var a = this.readI32();
    return this.trans.readString(a)
  };
  l.prototype.getTransport = function() {
    return this.trans
  };
  l.prototype.skip = function(a) {
    switch(a) {
      case x.STOP:
        break;
      case x.BOOL:
        this.readBool();
        break;
      case x.BYTE:
        this.readByte();
        break;
      case x.I16:
        this.readI16();
        break;
      case x.I32:
        this.readI32();
        break;
      case x.I64:
        this.readI64();
        break;
      case x.DOUBLE:
        this.readDouble();
        break;
      case x.STRING:
        this.readString();
        break;
      case x.STRUCT:
        for(this.readStructBegin();;) {
          a = this.readFieldBegin();
          if(a.ftype === x.STOP) {
            break
          }
          this.skip(a.ftype);
          this.readFieldEnd()
        }
        this.readStructEnd();
        break;
      case x.MAP:
        a = this.readMapBegin();
        for(var c = 0;c < a.size;++c) {
          this.skip(a.ktype), this.skip(a.vtype)
        }
        this.readMapEnd();
        break;
      case x.SET:
        a = this.readSetBegin();
        for(c = 0;c < a.size;++c) {
          this.skip(a.etype)
        }
        this.readSetEnd();
        break;
      case x.LIST:
        a = this.readListBegin();
        for(c = 0;c < a.size;++c) {
          this.skip(a.etype)
        }
        this.readListEnd();
        break;
      default:
        throw Error("Invalid type: " + a);
    }
  };
  var ia = new A(0), M = d.TTransport = function(a, c) {
    this.buf = a || ia;
    this.onFlush = c;
    this.reset()
  };
  M.receiver = function(a) {
    return function(c) {
      a(new M(c))
    }
  };
  M.prototype = {commitPosition:function() {
  }, rollbackPosition:function() {
  }, reset:function() {
    this.pos = 0
  }, isOpen:function() {
    return!0
  }, open:function() {
  }, close:function() {
  }, read:function(a) {
    var c = this.pos + a;
    if(this.buf.length < c) {
      throw Error("read(" + a + ") failed - not enough data");
    }
    a = this.buf.slice(this.pos, c);
    this.pos = c;
    return a
  }, readByte:function() {
    return this.buf.getInt8(this.pos++)
  }, readI16:function() {
    var a = this.buf.getInt16(this.pos);
    this.pos += 2;
    return a
  }, readI32:function() {
    var a = this.buf.getInt32(this.pos);
    this.pos += 4;
    return a
  }, readDouble:function() {
    var a = this.buf.getFloat64(this.pos);
    this.pos += 8;
    return a
  }, readString:function(a) {
    var c = this.buf.getUtf8String(this.pos, a);
    this.pos += a;
    return c
  }, readAll:function() {
    return this.buf
  }, writeByte:function(a) {
    this.buf.setInt8(this.pos++, a)
  }, writeI16:function(a) {
    this.buf.setInt16(this.pos, a);
    this.pos += 2
  }, writeI32:function(a) {
    this.buf.setInt32(this.pos, a);
    this.pos += 4
  }, writeI64:function(a) {
    this.buf.setInt64(this.pos, a);
    this.pos += 8
  }, writeDouble:function(a) {
    this.buf.setFloat64(this.pos, a);
    this.pos += 8
  }, write:function(a) {
    "string" === typeof a ? this.pos += this.setUtf8String(this.pos, a) : (this.setBuffer(this.pos, a), this.pos += a.length)
  }, writeWithLength:function(a) {
    "string" === typeof a ? a = this.buf.setUtf8String(this.pos + 4, a) : (this.setBuffer(this.pos + 4, a), a = a.length);
    this.buf.setInt32(this.pos, a);
    this.pos += a + 4
  }, flush:function(a) {
    if(a = a || this.onFlush) {
      var c = this.buf.slice(0, this.pos);
      a(c)
    }
  }};
  var Z = d.TFramedTransport = function(a, c) {
    M.call(this, a, c)
  };
  Z.receiver = function(a) {
    var c = 0, b = 0, e = null, g = null;
    return function(f) {
      if(g) {
        var t = new A(f.length + g.length);
        g.copy(t, 0, 0);
        f.copy(t, g.length, 0);
        g = null
      }
      for(;f.length;) {
        if(0 === c) {
          if(4 > f.length) {
            console.log("Expecting \x3e 4 bytes, found only " + f.length);
            g = f;
            break
          }
          c = binary.readI32(f, 0);
          e = new A(c);
          b = 0;
          f = f.slice(4, f.length)
        }
        f.length >= c ? (f.copy(e, b, 0, c), f = f.slice(c, f.length), c = 0, a(new Z(e))) : f.length && (f.copy(e, b, 0, f.length), c -= f.length, b += f.length, f = f.slice(f.length, f.length))
      }
    }
  };
  I(Z, M, {flush:function() {
    var a = this;
    M.prototype.flush.call(this, function(c) {
      if(a.onFlush) {
        var b = new A(c.length + 4);
        binary.writeI32(b, c.length);
        c.copy(b, 4, 0, c.length);
        a.onFlush(b)
      }
    })
  }});
  var J, B, C, E, L;
  TAction = {HEARTBEAT:0, ACK:1, NACK:2, CONNECT:3, CONNECTED:4, DISCONNECT:5, DISCONNECTED:6, CLOSE:7, CLOSED:8, ERROR:9, ATTACH:10, ATTACHED:11, DETACH:12, DETACHED:13, PRESENCE:14, MESSAGE:15};
  TType = {NONE:0, TRUE:1, FALSE:2, INT32:3, INT64:4, DOUBLE:5, STRING:6, BUFFER:7, JSONARRAY:8, JSONOBJECT:9};
  TFlags = {SYNC_TIME:0};
  TPresenceState = {ENTER:0, LEAVE:1, UPDATE:2};
  J = function(a) {
    this.reason = this.code = this.statusCode = void 0;
    a && (void 0 !== a.statusCode && (this.statusCode = a.statusCode), void 0 !== a.code && (this.code = a.code), void 0 !== a.reason && (this.reason = a.reason))
  };
  J.prototype = {};
  J.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.I16 ? this.statusCode = a.readI16() : a.skip(b);
          break;
        case 2:
          b == d.Type.I16 ? this.code = a.readI16() : a.skip(b);
          break;
        case 3:
          b == d.Type.STRING ? this.reason = a.readString() : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  J.prototype.write = function(a) {
    a.writeStructBegin("TError");
    void 0 !== this.statusCode && (a.writeFieldBegin("statusCode", d.Type.I16, 1), a.writeI16(this.statusCode), a.writeFieldEnd());
    void 0 !== this.code && (a.writeFieldBegin("code", d.Type.I16, 2), a.writeI16(this.code), a.writeFieldEnd());
    void 0 !== this.reason && (a.writeFieldBegin("reason", d.Type.STRING, 3), a.writeString(this.reason), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  B = function(a) {
    this.cipherData = this.binaryData = this.stringData = this.doubleData = this.i64Data = this.i32Data = this.type = void 0;
    a && (void 0 !== a.type && (this.type = a.type), void 0 !== a.i32Data && (this.i32Data = a.i32Data), void 0 !== a.i64Data && (this.i64Data = a.i64Data), void 0 !== a.doubleData && (this.doubleData = a.doubleData), void 0 !== a.stringData && (this.stringData = a.stringData), void 0 !== a.binaryData && (this.binaryData = a.binaryData), void 0 !== a.cipherData && (this.cipherData = a.cipherData))
  };
  B.prototype = {};
  B.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.I32 ? this.type = a.readI32() : a.skip(b);
          break;
        case 2:
          b == d.Type.I32 ? this.i32Data = a.readI32() : a.skip(b);
          break;
        case 3:
          b == d.Type.I64 ? this.i64Data = a.readI64() : a.skip(b);
          break;
        case 4:
          b == d.Type.DOUBLE ? this.doubleData = a.readDouble() : a.skip(b);
          break;
        case 5:
          b == d.Type.STRING ? this.stringData = a.readString() : a.skip(b);
          break;
        case 6:
          b == d.Type.STRING ? this.binaryData = a.readBinary() : a.skip(b);
          break;
        case 7:
          b == d.Type.STRING ? this.cipherData = a.readBinary() : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  B.prototype.write = function(a) {
    a.writeStructBegin("TData");
    void 0 !== this.type && (a.writeFieldBegin("type", d.Type.I32, 1), a.writeI32(this.type), a.writeFieldEnd());
    void 0 !== this.i32Data && (a.writeFieldBegin("i32Data", d.Type.I32, 2), a.writeI32(this.i32Data), a.writeFieldEnd());
    void 0 !== this.i64Data && (a.writeFieldBegin("i64Data", d.Type.I64, 3), a.writeI64(this.i64Data), a.writeFieldEnd());
    void 0 !== this.doubleData && (a.writeFieldBegin("doubleData", d.Type.DOUBLE, 4), a.writeDouble(this.doubleData), a.writeFieldEnd());
    void 0 !== this.stringData && (a.writeFieldBegin("stringData", d.Type.STRING, 5), a.writeString(this.stringData), a.writeFieldEnd());
    void 0 !== this.binaryData && (a.writeFieldBegin("binaryData", d.Type.STRING, 6), a.writeString(this.binaryData), a.writeFieldEnd());
    void 0 !== this.cipherData && (a.writeFieldBegin("cipherData", d.Type.STRING, 7), a.writeString(this.cipherData), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  C = function(a) {
    this.instanceId = this.connectionId = this.inheritMemberId = this.memberId = this.clientData = this.clientId = this.state = void 0;
    a && (void 0 !== a.state && (this.state = a.state), void 0 !== a.clientId && (this.clientId = a.clientId), void 0 !== a.clientData && (this.clientData = a.clientData), void 0 !== a.memberId && (this.memberId = a.memberId), void 0 !== a.inheritMemberId && (this.inheritMemberId = a.inheritMemberId), void 0 !== a.connectionId && (this.connectionId = a.connectionId), void 0 !== a.instanceId && (this.instanceId = a.instanceId))
  };
  C.prototype = {};
  C.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.I32 ? this.state = a.readI32() : a.skip(b);
          break;
        case 2:
          b == d.Type.STRING ? this.clientId = a.readString() : a.skip(b);
          break;
        case 3:
          b == d.Type.STRUCT ? (this.clientData = new B, this.clientData.read(a)) : a.skip(b);
          break;
        case 4:
          b == d.Type.STRING ? this.memberId = a.readString() : a.skip(b);
          break;
        case 5:
          b == d.Type.STRING ? this.inheritMemberId = a.readString() : a.skip(b);
          break;
        case 6:
          b == d.Type.STRING ? this.connectionId = a.readString() : a.skip(b);
          break;
        case 7:
          b == d.Type.STRING ? this.instanceId = a.readString() : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  C.prototype.write = function(a) {
    a.writeStructBegin("TPresence");
    void 0 !== this.state && (a.writeFieldBegin("state", d.Type.I32, 1), a.writeI32(this.state), a.writeFieldEnd());
    void 0 !== this.clientId && (a.writeFieldBegin("clientId", d.Type.STRING, 2), a.writeString(this.clientId), a.writeFieldEnd());
    void 0 !== this.clientData && (a.writeFieldBegin("clientData", d.Type.STRUCT, 3), this.clientData.write(a), a.writeFieldEnd());
    void 0 !== this.memberId && (a.writeFieldBegin("memberId", d.Type.STRING, 4), a.writeString(this.memberId), a.writeFieldEnd());
    void 0 !== this.inheritMemberId && (a.writeFieldBegin("inheritMemberId", d.Type.STRING, 5), a.writeString(this.inheritMemberId), a.writeFieldEnd());
    void 0 !== this.connectionId && (a.writeFieldBegin("connectionId", d.Type.STRING, 6), a.writeString(this.connectionId), a.writeFieldEnd());
    void 0 !== this.instanceId && (a.writeFieldBegin("instanceId", d.Type.STRING, 7), a.writeString(this.instanceId), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  TPresenceArray = function(a) {
    this.items = void 0;
    a && void 0 !== a.items && (this.items = a.items)
  };
  TPresenceArray.prototype = {};
  TPresenceArray.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          if(b == d.Type.LIST) {
            c = 0;
            this.items = [];
            c = a.readListBegin().size;
            for(b = 0;b < c;++b) {
              var e = void 0, e = new C;
              e.read(a);
              this.items.push(e)
            }
            a.readListEnd()
          }else {
            a.skip(b)
          }
          break;
        case 0:
          a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  TPresenceArray.prototype.write = function(a) {
    a.writeStructBegin("TPresenceArray");
    if(void 0 !== this.items) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var c in this.items) {
        this.items.hasOwnProperty(c) && (c = this.items[c], c.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  E = function(a) {
    this.tags = this.data = this.timestamp = this.clientId = this.name = void 0;
    a && (void 0 !== a.name && (this.name = a.name), void 0 !== a.clientId && (this.clientId = a.clientId), void 0 !== a.timestamp && (this.timestamp = a.timestamp), void 0 !== a.data && (this.data = a.data), void 0 !== a.tags && (this.tags = a.tags))
  };
  E.prototype = {};
  E.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.STRING ? this.name = a.readString() : a.skip(b);
          break;
        case 2:
          b == d.Type.STRING ? this.clientId = a.readString() : a.skip(b);
          break;
        case 3:
          b == d.Type.I64 ? this.timestamp = a.readI64() : a.skip(b);
          break;
        case 4:
          b == d.Type.STRUCT ? (this.data = new B, this.data.read(a)) : a.skip(b);
          break;
        case 5:
          if(b == d.Type.LIST) {
            c = 0;
            this.tags = [];
            c = a.readListBegin().size;
            for(b = 0;b < c;++b) {
              var e = void 0, e = a.readString();
              this.tags.push(e)
            }
            a.readListEnd()
          }else {
            a.skip(b)
          }
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  E.prototype.write = function(a) {
    a.writeStructBegin("TMessage");
    void 0 !== this.name && (a.writeFieldBegin("name", d.Type.STRING, 1), a.writeString(this.name), a.writeFieldEnd());
    void 0 !== this.clientId && (a.writeFieldBegin("clientId", d.Type.STRING, 2), a.writeString(this.clientId), a.writeFieldEnd());
    void 0 !== this.timestamp && (a.writeFieldBegin("timestamp", d.Type.I64, 3), a.writeI64(this.timestamp), a.writeFieldEnd());
    void 0 !== this.data && (a.writeFieldBegin("data", d.Type.STRUCT, 4), this.data.write(a), a.writeFieldEnd());
    if(void 0 !== this.tags) {
      a.writeFieldBegin("tags", d.Type.LIST, 5);
      a.writeListBegin(d.Type.STRING, this.tags.length);
      for(var c in this.tags) {
        this.tags.hasOwnProperty(c) && (c = this.tags[c], a.writeString(c))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  TMessageArray = function(a) {
    this.items = void 0;
    a && void 0 !== a.items && (this.items = a.items)
  };
  TMessageArray.prototype = {};
  TMessageArray.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          if(b == d.Type.LIST) {
            c = 0;
            this.items = [];
            c = a.readListBegin().size;
            for(b = 0;b < c;++b) {
              var e = void 0, e = new E;
              e.read(a);
              this.items.push(e)
            }
            a.readListEnd()
          }else {
            a.skip(b)
          }
          break;
        case 0:
          a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  TMessageArray.prototype.write = function(a) {
    a.writeStructBegin("TMessageArray");
    if(void 0 !== this.items) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var c in this.items) {
        this.items.hasOwnProperty(c) && (c = this.items[c], c.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  L = function(a) {
    this.presence = this.messages = this.timestamp = this.msgSerial = this.channelSerial = this.channel = this.connectionSerial = this.connectionId = this.applicationId = this.error = this.count = this.flags = this.action = void 0;
    a && (void 0 !== a.action && (this.action = a.action), void 0 !== a.flags && (this.flags = a.flags), void 0 !== a.count && (this.count = a.count), void 0 !== a.error && (this.error = a.error), void 0 !== a.applicationId && (this.applicationId = a.applicationId), void 0 !== a.connectionId && (this.connectionId = a.connectionId), void 0 !== a.connectionSerial && (this.connectionSerial = a.connectionSerial), void 0 !== a.channel && (this.channel = a.channel), void 0 !== a.channelSerial && (this.channelSerial = 
    a.channelSerial), void 0 !== a.msgSerial && (this.msgSerial = a.msgSerial), void 0 !== a.timestamp && (this.timestamp = a.timestamp), void 0 !== a.messages && (this.messages = a.messages), void 0 !== a.presence && (this.presence = a.presence))
  };
  L.prototype = {};
  L.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.I32 ? this.action = a.readI32() : a.skip(b);
          break;
        case 2:
          b == d.Type.BYTE ? this.flags = a.readByte() : a.skip(b);
          break;
        case 3:
          b == d.Type.I32 ? this.count = a.readI32() : a.skip(b);
          break;
        case 4:
          b == d.Type.STRUCT ? (this.error = new J, this.error.read(a)) : a.skip(b);
          break;
        case 5:
          b == d.Type.STRING ? this.applicationId = a.readString() : a.skip(b);
          break;
        case 6:
          b == d.Type.STRING ? this.connectionId = a.readString() : a.skip(b);
          break;
        case 7:
          b == d.Type.I64 ? this.connectionSerial = a.readI64() : a.skip(b);
          break;
        case 8:
          b == d.Type.STRING ? this.channel = a.readString() : a.skip(b);
          break;
        case 9:
          b == d.Type.STRING ? this.channelSerial = a.readString() : a.skip(b);
          break;
        case 10:
          b == d.Type.I64 ? this.msgSerial = a.readI64() : a.skip(b);
          break;
        case 11:
          b == d.Type.I64 ? this.timestamp = a.readI64() : a.skip(b);
          break;
        case 12:
          if(b == d.Type.LIST) {
            c = 0;
            this.messages = [];
            c = a.readListBegin().size;
            for(b = 0;b < c;++b) {
              var e = void 0, e = new E;
              e.read(a);
              this.messages.push(e)
            }
            a.readListEnd()
          }else {
            a.skip(b)
          }
          break;
        case 13:
          if(b == d.Type.LIST) {
            c = 0;
            this.presence = [];
            c = a.readListBegin().size;
            for(b = 0;b < c;++b) {
              e = void 0, e = new C, e.read(a), this.presence.push(e)
            }
            a.readListEnd()
          }else {
            a.skip(b)
          }
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  L.prototype.write = function(a) {
    a.writeStructBegin("TProtocolMessage");
    void 0 !== this.action && (a.writeFieldBegin("action", d.Type.I32, 1), a.writeI32(this.action), a.writeFieldEnd());
    void 0 !== this.flags && (a.writeFieldBegin("flags", d.Type.BYTE, 2), a.writeByte(this.flags), a.writeFieldEnd());
    void 0 !== this.count && (a.writeFieldBegin("count", d.Type.I32, 3), a.writeI32(this.count), a.writeFieldEnd());
    void 0 !== this.error && (a.writeFieldBegin("error", d.Type.STRUCT, 4), this.error.write(a), a.writeFieldEnd());
    void 0 !== this.applicationId && (a.writeFieldBegin("applicationId", d.Type.STRING, 5), a.writeString(this.applicationId), a.writeFieldEnd());
    void 0 !== this.connectionId && (a.writeFieldBegin("connectionId", d.Type.STRING, 6), a.writeString(this.connectionId), a.writeFieldEnd());
    void 0 !== this.connectionSerial && (a.writeFieldBegin("connectionSerial", d.Type.I64, 7), a.writeI64(this.connectionSerial), a.writeFieldEnd());
    void 0 !== this.channel && (a.writeFieldBegin("channel", d.Type.STRING, 8), a.writeString(this.channel), a.writeFieldEnd());
    void 0 !== this.channelSerial && (a.writeFieldBegin("channelSerial", d.Type.STRING, 9), a.writeString(this.channelSerial), a.writeFieldEnd());
    void 0 !== this.msgSerial && (a.writeFieldBegin("msgSerial", d.Type.I64, 10), a.writeI64(this.msgSerial), a.writeFieldEnd());
    void 0 !== this.timestamp && (a.writeFieldBegin("timestamp", d.Type.I64, 11), a.writeI64(this.timestamp), a.writeFieldEnd());
    if(void 0 !== this.messages) {
      a.writeFieldBegin("messages", d.Type.LIST, 12);
      a.writeListBegin(d.Type.STRUCT, this.messages.length);
      for(var c in this.messages) {
        this.messages.hasOwnProperty(c) && (c = this.messages[c], c.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    if(void 0 !== this.presence) {
      a.writeFieldBegin("presence", d.Type.LIST, 13);
      a.writeListBegin(d.Type.STRUCT, this.presence.length);
      for(var b in this.presence) {
        this.presence.hasOwnProperty(b) && (b = this.presence[b], b.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  TMessageBundle = function(a) {
    this.items = void 0;
    a && void 0 !== a.items && (this.items = a.items)
  };
  TMessageBundle.prototype = {};
  TMessageBundle.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          if(b == d.Type.LIST) {
            c = 0;
            this.items = [];
            c = a.readListBegin().size;
            for(b = 0;b < c;++b) {
              var e = void 0, e = new L;
              e.read(a);
              this.items.push(e)
            }
            a.readListEnd()
          }else {
            a.skip(b)
          }
          break;
        case 0:
          a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  TMessageBundle.prototype.write = function(a) {
    a.writeStructBegin("TMessageBundle");
    if(void 0 !== this.items) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var c in this.items) {
        this.items.hasOwnProperty(c) && (c = this.items[c], c.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SMessageCount = function(a) {
    this.data = this.count = void 0;
    a && (void 0 !== a.count && (this.count = a.count), void 0 !== a.data && (this.data = a.data))
  };
  SMessageCount.prototype = {};
  SMessageCount.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.DOUBLE ? this.count = a.readDouble() : a.skip(b);
          break;
        case 2:
          b == d.Type.DOUBLE ? this.data = a.readDouble() : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SMessageCount.prototype.write = function(a) {
    a.writeStructBegin("SMessageCount");
    void 0 !== this.count && (a.writeFieldBegin("count", d.Type.DOUBLE, 1), a.writeDouble(this.count), a.writeFieldEnd());
    void 0 !== this.data && (a.writeFieldBegin("data", d.Type.DOUBLE, 2), a.writeDouble(this.data), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SMessageTypes = function(a) {
    this.presence = this.messages = this.all = void 0;
    a && (void 0 !== a.all && (this.all = a.all), void 0 !== a.messages && (this.messages = a.messages), void 0 !== a.presence && (this.presence = a.presence))
  };
  SMessageTypes.prototype = {};
  SMessageTypes.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.STRUCT ? (this.all = new SMessageCount, this.all.read(a)) : a.skip(b);
          break;
        case 2:
          b == d.Type.STRUCT ? (this.messages = new SMessageCount, this.messages.read(a)) : a.skip(b);
          break;
        case 3:
          b == d.Type.STRUCT ? (this.presence = new SMessageCount, this.presence.read(a)) : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SMessageTypes.prototype.write = function(a) {
    a.writeStructBegin("SMessageTypes");
    void 0 !== this.all && (a.writeFieldBegin("all", d.Type.STRUCT, 1), this.all.write(a), a.writeFieldEnd());
    void 0 !== this.messages && (a.writeFieldBegin("messages", d.Type.STRUCT, 2), this.messages.write(a), a.writeFieldEnd());
    void 0 !== this.presence && (a.writeFieldBegin("presence", d.Type.STRUCT, 3), this.presence.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SResourceCount = function(a) {
    this.sample_sum = this.sample_count = this.refused = this.min = this.mean = this.peak = this.opened = void 0;
    a && (void 0 !== a.opened && (this.opened = a.opened), void 0 !== a.peak && (this.peak = a.peak), void 0 !== a.mean && (this.mean = a.mean), void 0 !== a.min && (this.min = a.min), void 0 !== a.refused && (this.refused = a.refused), void 0 !== a.sample_count && (this.sample_count = a.sample_count), void 0 !== a.sample_sum && (this.sample_sum = a.sample_sum))
  };
  SResourceCount.prototype = {};
  SResourceCount.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.DOUBLE ? this.opened = a.readDouble() : a.skip(b);
          break;
        case 2:
          b == d.Type.DOUBLE ? this.peak = a.readDouble() : a.skip(b);
          break;
        case 3:
          b == d.Type.DOUBLE ? this.mean = a.readDouble() : a.skip(b);
          break;
        case 4:
          b == d.Type.DOUBLE ? this.min = a.readDouble() : a.skip(b);
          break;
        case 5:
          b == d.Type.DOUBLE ? this.refused = a.readDouble() : a.skip(b);
          break;
        case 10:
          b == d.Type.DOUBLE ? this.sample_count = a.readDouble() : a.skip(b);
          break;
        case 11:
          b == d.Type.DOUBLE ? this.sample_sum = a.readDouble() : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SResourceCount.prototype.write = function(a) {
    a.writeStructBegin("SResourceCount");
    void 0 !== this.opened && (a.writeFieldBegin("opened", d.Type.DOUBLE, 1), a.writeDouble(this.opened), a.writeFieldEnd());
    void 0 !== this.peak && (a.writeFieldBegin("peak", d.Type.DOUBLE, 2), a.writeDouble(this.peak), a.writeFieldEnd());
    void 0 !== this.mean && (a.writeFieldBegin("mean", d.Type.DOUBLE, 3), a.writeDouble(this.mean), a.writeFieldEnd());
    void 0 !== this.min && (a.writeFieldBegin("min", d.Type.DOUBLE, 4), a.writeDouble(this.min), a.writeFieldEnd());
    void 0 !== this.refused && (a.writeFieldBegin("refused", d.Type.DOUBLE, 5), a.writeDouble(this.refused), a.writeFieldEnd());
    void 0 !== this.sample_count && (a.writeFieldBegin("sample_count", d.Type.DOUBLE, 10), a.writeDouble(this.sample_count), a.writeFieldEnd());
    void 0 !== this.sample_sum && (a.writeFieldBegin("sample_sum", d.Type.DOUBLE, 11), a.writeDouble(this.sample_sum), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SConnectionTypes = function(a) {
    this.tls = this.plain = this.all = void 0;
    a && (void 0 !== a.all && (this.all = a.all), void 0 !== a.plain && (this.plain = a.plain), void 0 !== a.tls && (this.tls = a.tls))
  };
  SConnectionTypes.prototype = {};
  SConnectionTypes.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.STRUCT ? (this.all = new SResourceCount, this.all.read(a)) : a.skip(b);
          break;
        case 2:
          b == d.Type.STRUCT ? (this.plain = new SResourceCount, this.plain.read(a)) : a.skip(b);
          break;
        case 3:
          b == d.Type.STRUCT ? (this.tls = new SResourceCount, this.tls.read(a)) : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SConnectionTypes.prototype.write = function(a) {
    a.writeStructBegin("SConnectionTypes");
    void 0 !== this.all && (a.writeFieldBegin("all", d.Type.STRUCT, 1), this.all.write(a), a.writeFieldEnd());
    void 0 !== this.plain && (a.writeFieldBegin("plain", d.Type.STRUCT, 2), this.plain.write(a), a.writeFieldEnd());
    void 0 !== this.tls && (a.writeFieldBegin("tls", d.Type.STRUCT, 3), this.tls.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SMessageTraffic = function(a) {
    this.httpStream = this.push = this.rest = this.realtime = this.all = void 0;
    a && (void 0 !== a.all && (this.all = a.all), void 0 !== a.realtime && (this.realtime = a.realtime), void 0 !== a.rest && (this.rest = a.rest), void 0 !== a.push && (this.push = a.push), void 0 !== a.httpStream && (this.httpStream = a.httpStream))
  };
  SMessageTraffic.prototype = {};
  SMessageTraffic.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.STRUCT ? (this.all = new SMessageTypes, this.all.read(a)) : a.skip(b);
          break;
        case 2:
          b == d.Type.STRUCT ? (this.realtime = new SMessageTypes, this.realtime.read(a)) : a.skip(b);
          break;
        case 3:
          b == d.Type.STRUCT ? (this.rest = new SMessageTypes, this.rest.read(a)) : a.skip(b);
          break;
        case 4:
          b == d.Type.STRUCT ? (this.push = new SMessageTypes, this.push.read(a)) : a.skip(b);
          break;
        case 5:
          b == d.Type.STRUCT ? (this.httpStream = new SMessageTypes, this.httpStream.read(a)) : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SMessageTraffic.prototype.write = function(a) {
    a.writeStructBegin("SMessageTraffic");
    void 0 !== this.all && (a.writeFieldBegin("all", d.Type.STRUCT, 1), this.all.write(a), a.writeFieldEnd());
    void 0 !== this.realtime && (a.writeFieldBegin("realtime", d.Type.STRUCT, 2), this.realtime.write(a), a.writeFieldEnd());
    void 0 !== this.rest && (a.writeFieldBegin("rest", d.Type.STRUCT, 3), this.rest.write(a), a.writeFieldEnd());
    void 0 !== this.push && (a.writeFieldBegin("push", d.Type.STRUCT, 4), this.push.write(a), a.writeFieldEnd());
    void 0 !== this.httpStream && (a.writeFieldBegin("httpStream", d.Type.STRUCT, 5), this.httpStream.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SRequestCount = function(a) {
    this.refused = this.failed = this.succeeded = void 0;
    a && (void 0 !== a.succeeded && (this.succeeded = a.succeeded), void 0 !== a.failed && (this.failed = a.failed), void 0 !== a.refused && (this.refused = a.refused))
  };
  SRequestCount.prototype = {};
  SRequestCount.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.DOUBLE ? this.succeeded = a.readDouble() : a.skip(b);
          break;
        case 2:
          b == d.Type.DOUBLE ? this.failed = a.readDouble() : a.skip(b);
          break;
        case 3:
          b == d.Type.DOUBLE ? this.refused = a.readDouble() : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SRequestCount.prototype.write = function(a) {
    a.writeStructBegin("SRequestCount");
    void 0 !== this.succeeded && (a.writeFieldBegin("succeeded", d.Type.DOUBLE, 1), a.writeDouble(this.succeeded), a.writeFieldEnd());
    void 0 !== this.failed && (a.writeFieldBegin("failed", d.Type.DOUBLE, 2), a.writeDouble(this.failed), a.writeFieldEnd());
    void 0 !== this.refused && (a.writeFieldBegin("refused", d.Type.DOUBLE, 3), a.writeDouble(this.refused), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SStats = function(a) {
    this.count = this.inProgress = this.tokenRequests = this.apiRequests = this.channels = this.connections = this.persisted = this.outbound = this.inbound = this.all = void 0;
    a && (void 0 !== a.all && (this.all = a.all), void 0 !== a.inbound && (this.inbound = a.inbound), void 0 !== a.outbound && (this.outbound = a.outbound), void 0 !== a.persisted && (this.persisted = a.persisted), void 0 !== a.connections && (this.connections = a.connections), void 0 !== a.channels && (this.channels = a.channels), void 0 !== a.apiRequests && (this.apiRequests = a.apiRequests), void 0 !== a.tokenRequests && (this.tokenRequests = a.tokenRequests), void 0 !== a.inProgress && (this.inProgress = 
    a.inProgress), void 0 !== a.count && (this.count = a.count))
  };
  SStats.prototype = {};
  SStats.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.STRUCT ? (this.all = new SMessageTypes, this.all.read(a)) : a.skip(b);
          break;
        case 2:
          b == d.Type.STRUCT ? (this.inbound = new SMessageTraffic, this.inbound.read(a)) : a.skip(b);
          break;
        case 3:
          b == d.Type.STRUCT ? (this.outbound = new SMessageTraffic, this.outbound.read(a)) : a.skip(b);
          break;
        case 4:
          b == d.Type.STRUCT ? (this.persisted = new SMessageTypes, this.persisted.read(a)) : a.skip(b);
          break;
        case 5:
          b == d.Type.STRUCT ? (this.connections = new SConnectionTypes, this.connections.read(a)) : a.skip(b);
          break;
        case 6:
          b == d.Type.STRUCT ? (this.channels = new SResourceCount, this.channels.read(a)) : a.skip(b);
          break;
        case 7:
          b == d.Type.STRUCT ? (this.apiRequests = new SRequestCount, this.apiRequests.read(a)) : a.skip(b);
          break;
        case 8:
          b == d.Type.STRUCT ? (this.tokenRequests = new SRequestCount, this.tokenRequests.read(a)) : a.skip(b);
          break;
        case 10:
          b == d.Type.STRING ? this.inProgress = a.readString() : a.skip(b);
          break;
        case 11:
          b == d.Type.I32 ? this.count = a.readI32() : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SStats.prototype.write = function(a) {
    a.writeStructBegin("SStats");
    void 0 !== this.all && (a.writeFieldBegin("all", d.Type.STRUCT, 1), this.all.write(a), a.writeFieldEnd());
    void 0 !== this.inbound && (a.writeFieldBegin("inbound", d.Type.STRUCT, 2), this.inbound.write(a), a.writeFieldEnd());
    void 0 !== this.outbound && (a.writeFieldBegin("outbound", d.Type.STRUCT, 3), this.outbound.write(a), a.writeFieldEnd());
    void 0 !== this.persisted && (a.writeFieldBegin("persisted", d.Type.STRUCT, 4), this.persisted.write(a), a.writeFieldEnd());
    void 0 !== this.connections && (a.writeFieldBegin("connections", d.Type.STRUCT, 5), this.connections.write(a), a.writeFieldEnd());
    void 0 !== this.channels && (a.writeFieldBegin("channels", d.Type.STRUCT, 6), this.channels.write(a), a.writeFieldEnd());
    void 0 !== this.apiRequests && (a.writeFieldBegin("apiRequests", d.Type.STRUCT, 7), this.apiRequests.write(a), a.writeFieldEnd());
    void 0 !== this.tokenRequests && (a.writeFieldBegin("tokenRequests", d.Type.STRUCT, 8), this.tokenRequests.write(a), a.writeFieldEnd());
    void 0 !== this.inProgress && (a.writeFieldBegin("inProgress", d.Type.STRING, 10), a.writeString(this.inProgress), a.writeFieldEnd());
    void 0 !== this.count && (a.writeFieldBegin("count", d.Type.I32, 11), a.writeI32(this.count), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SStatsArray = function(a) {
    this.items = void 0;
    a && void 0 !== a.items && (this.items = a.items)
  };
  SStatsArray.prototype = {};
  SStatsArray.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          if(b == d.Type.LIST) {
            c = 0;
            this.items = [];
            c = a.readListBegin().size;
            for(b = 0;b < c;++b) {
              var e = void 0, e = new SStats;
              e.read(a);
              this.items.push(e)
            }
            a.readListEnd()
          }else {
            a.skip(b)
          }
          break;
        case 0:
          a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SStatsArray.prototype.write = function(a) {
    a.writeStructBegin("SStatsArray");
    if(void 0 !== this.items) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var c in this.items) {
        this.items.hasOwnProperty(c) && (c = this.items[c], c.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  WWebhookMessage = function(a) {
    this.data = this.serial = this.timestamp = this.webhookId = this.name = void 0;
    a && (void 0 !== a.name && (this.name = a.name), void 0 !== a.webhookId && (this.webhookId = a.webhookId), void 0 !== a.timestamp && (this.timestamp = a.timestamp), void 0 !== a.serial && (this.serial = a.serial), void 0 !== a.data && (this.data = a.data))
  };
  WWebhookMessage.prototype = {};
  WWebhookMessage.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          b == d.Type.STRING ? this.name = a.readString() : a.skip(b);
          break;
        case 2:
          b == d.Type.STRING ? this.webhookId = a.readString() : a.skip(b);
          break;
        case 3:
          b == d.Type.I64 ? this.timestamp = a.readI64() : a.skip(b);
          break;
        case 4:
          b == d.Type.STRING ? this.serial = a.readString() : a.skip(b);
          break;
        case 5:
          b == d.Type.STRUCT ? (this.data = new B, this.data.read(a)) : a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  WWebhookMessage.prototype.write = function(a) {
    a.writeStructBegin("WWebhookMessage");
    void 0 !== this.name && (a.writeFieldBegin("name", d.Type.STRING, 1), a.writeString(this.name), a.writeFieldEnd());
    void 0 !== this.webhookId && (a.writeFieldBegin("webhookId", d.Type.STRING, 2), a.writeString(this.webhookId), a.writeFieldEnd());
    void 0 !== this.timestamp && (a.writeFieldBegin("timestamp", d.Type.I64, 3), a.writeI64(this.timestamp), a.writeFieldEnd());
    void 0 !== this.serial && (a.writeFieldBegin("serial", d.Type.STRING, 4), a.writeString(this.serial), a.writeFieldEnd());
    void 0 !== this.data && (a.writeFieldBegin("data", d.Type.STRUCT, 5), this.data.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  WWebhookMessageArray = function(a) {
    this.items = void 0;
    a && void 0 !== a.items && (this.items = a.items)
  };
  WWebhookMessageArray.prototype = {};
  WWebhookMessageArray.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var c = a.readFieldBegin(), b = c.ftype;
      if(b == d.Type.STOP) {
        break
      }
      switch(c.fid) {
        case 1:
          if(b == d.Type.LIST) {
            c = 0;
            this.items = [];
            c = a.readListBegin().size;
            for(b = 0;b < c;++b) {
              var e = void 0, e = new WWebhookMessage;
              e.read(a);
              this.items.push(e)
            }
            a.readListEnd()
          }else {
            a.skip(b)
          }
          break;
        case 0:
          a.skip(b);
          break;
        default:
          a.skip(b)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  WWebhookMessageArray.prototype.write = function(a) {
    a.writeStructBegin("WWebhookMessageArray");
    if(void 0 !== this.items) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var c in this.items) {
        this.items.hasOwnProperty(c) && (c = this.items[c], c.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  var w = {TAction:TAction, TFlags:TFlags, TType:TType, TError:J, TData:B, TPresence:C, TMessage:E, TChannelMessage:void 0, TProtocolMessage:L, TPresenceState:TPresenceState, TMessageArray:TMessageArray};
  this.Cookie = function() {
    function a() {
    }
    "object" == typeof window && (a.create = function(a, b, e) {
      var g = "";
      e && (g = new Date, g.setTime(g.getTime() + e), g = "; expires\x3d" + g.toGMTString());
      document.cookie = a + "\x3d" + b + g + "; path\x3d/"
    }, a.read = function(a) {
      a += "\x3d";
      for(var b = document.cookie.split(";"), e = 0;e < b.length;e++) {
        for(var g = b[e];" " == g.charAt(0);) {
          g = g.substring(1, g.length)
        }
        if(0 == g.indexOf(a)) {
          return g.substring(a.length, g.length)
        }
      }
      return null
    }, a.erase = function(a) {
      createCookie(a, "", -36E5)
    });
    return a
  }();
  var v = {protocolVersion:1, HOST:"rest.ably.io", WS_HOST:"realtime.ably.io", FALLBACK_HOSTS:["A.ably-realtime.com", "B.ably-realtime.com", "C.ably-realtime.com", "D.ably-realtime.com", "E.ably-realtime.com"], PORT:80, TLS_PORT:443, connectTimeout:15E3, disconnectTimeout:3E4, suspendedTimeout:12E4, cometRecvTimeout:9E4, cometSendTimeout:1E4, httpTransports:["xhr", "jsonp"], transports:["web_socket", "flash_socket", "xhr", "jsonp"], flashTransport:{swfLocation:("undefined" !== typeof window ? window.location.protocol : 
  "https:") + "//cdn.ably.io/lib/swf/WebSocketMainInsecure-0.9.swf"}, getHost:function(a, c, b) {
    c = c || a.host || v.HOST;
    b && (c = c == a.host && (a.wsHost || c) || c == v.HOST && (v.WS_HOST || c) || c);
    return c
  }, getPort:function(a) {
    return a.tls ? a.tlsPort || v.TLS_PORT : a.port || v.PORT
  }, getHosts:function(a) {
    var c;
    a.host ? (c = [a.host], a.fallbackHosts && c.concat(a.fallbackHosts)) : c = [v.HOST].concat(v.FALLBACK_HOSTS);
    return c
  }};
  "undefined" !== typeof exports && this.exports !== exports && (exports.defaults = v);
  this.Http = function() {
    function a() {
    }
    var c = function() {
    };
    a.get = function(b, e, g, f, t) {
      t = t || c;
      var d = "function" == typeof e ? e : function(a) {
        return b.baseUri(a) + e
      }, m, q = b.connection;
      m = q && "connected" == q.state ? [q.connectionManager.host] : v.getHosts(b.options);
      1 == m.length ? a.getUri(b, d(m[0]), g, f, t) : a.getUri(b, d(m.shift()), g, f, function(c) {
        if(c) {
          var e = c.code;
          if("ENETUNREACH" == e || "EHOSTUNREACH" == e || "EHOSTDOWN" == e) {
            a.getUri(b, d(m.shift()), g, f, t);
            return
          }
        }
        t.apply(null, arguments)
      })
    };
    a.getUri = function(b, e, g, f, t) {
      t = t || c;
      a.Request(e, f, g, null, g && "application/json" != g.accept, t)
    };
    a.post = function(b, e, g, f, t, d) {
      d = d || c;
      var m = "function" == typeof e ? e : function(a) {
        return b.baseUri(a) + e
      }, q, P = b.connection;
      q = P && "connected" == P.state ? [P.connectionManager.host] : v.getHosts(b.options);
      1 == q.length ? a.postUri(b, m(q[0]), g, f, t, d) : a.postUri(b, m(q.shift()), g, f, t, function(c) {
        if(c) {
          var e = c.code;
          if("ENETUNREACH" == e || "EHOSTUNREACH" == e || "EHOSTDOWN" == e) {
            a.postUri(b, m(q.shift()), g, f, t, d);
            return
          }
        }
        d.apply(null, arguments)
      })
    };
    a.postUri = function(b, e, g, f, d, n) {
      n = n || c;
      a.Request(e, d, g, f, g && "application/json" != g.accept, n)
    };
    a.supportsAuthHeaders = !1;
    return a
  }();
  this.ThriftUtil = function() {
    function a(a) {
      a = a || 0;
      if(f.length) {
        var b = f.shift();
        if(b.length >= a) {
          return b
        }
      }
      return new A(a || g)
    }
    function c() {
    }
    var b = new d.TTransport, e = new d.TBinaryProtocol(b), g = 16384, f = [];
    c.encode = function(a, b) {
      try {
        b(null, c.encodeSync(a))
      }catch(f) {
        var e = "Unexpected exception encoding Thrift; exception \x3d " + f;
        h.logAction(h.LOG_ERROR, "ThriftUtil.encode()", e, f);
        e = Error(e);
        e.statusCode = 400;
        b(e)
      }
    };
    c.encodeSync = function(c) {
      var g = void 0;
      if(c) {
        var d = a();
        b.reset(d, function(a) {
          g = a
        });
        c.write(e);
        e.flush();
        f.unshift(d)
      }
      return g
    };
    c.decode = function(a, b, f) {
      var e = c.decodeSync(a, b);
      e ? f(e) : f(null, a, b)
    };
    c.decodeSync = function(a, c) {
      try {
        return b.reset(c), a.read(e), a
      }catch(f) {
        var g = "Unexpected exception decoding thrift message; exception \x3d " + f;
        h.logAction(h.LOG_ERROR, "ThriftUtil.decode()", g, f);
        g = Error(g);
        g.statusCode = 400;
        throw g;
      }
    };
    return c
  }();
  this.Base64 = function() {
    function a() {
      this.buffer = []
    }
    function c(a) {
      this._input = a;
      this._index = -1;
      this._buffer = []
    }
    function b(a) {
      this._input = a;
      this._index = -1;
      this._buffer = []
    }
    a.prototype.append = function(a) {
      this.buffer.push(a);
      return this
    };
    a.prototype.toString = function() {
      return this.buffer.join("")
    };
    var e = {codex:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d", encode:function(b) {
      var f = new a, d = e.codex;
      for(b = new c(b);b.moveNext();) {
        var n = b.current;
        b.moveNext();
        var m = b.current;
        b.moveNext();
        var q = b.current, P = n >> 2, n = (n & 3) << 4 | m >> 4, h = (m & 15) << 2 | q >> 6, u = q & 63;
        isNaN(m) ? h = u = 64 : isNaN(q) && (u = 64);
        f.append(d.charAt(P) + d.charAt(n) + d.charAt(h) + d.charAt(u))
      }
      return f.toString()
    }, decode:function(c) {
      var f = new a;
      for(c = new b(c);c.moveNext();) {
        var e = c.current;
        if(128 > e) {
          f.append(String.fromCharCode(e))
        }else {
          if(191 < e && 224 > e) {
            c.moveNext();
            var d = c.current;
            f.append(String.fromCharCode((e & 31) << 6 | d & 63))
          }else {
            c.moveNext(), d = c.current, c.moveNext(), f.append(String.fromCharCode((e & 15) << 12 | (d & 63) << 6 | c.current & 63))
          }
        }
      }
      return f.toString()
    }};
    c.prototype = {current:Number.NaN, moveNext:function() {
      if(0 < this._buffer.length) {
        return this.current = this._buffer.shift(), !0
      }
      if(this._index >= this._input.length - 1) {
        return this.current = Number.NaN, !1
      }
      var a = this._input.charCodeAt(++this._index);
      13 == a && 10 == this._input.charCodeAt(this._index + 1) && (a = 10, this._index += 2);
      128 > a ? this.current = a : (127 < a && 2048 > a ? this.current = a >> 6 | 192 : (this.current = a >> 12 | 224, this._buffer.push(a >> 6 & 63 | 128)), this._buffer.push(a & 63 | 128));
      return!0
    }};
    b.prototype = {current:64, moveNext:function() {
      if(0 < this._buffer.length) {
        return this.current = this._buffer.shift(), !0
      }
      if(this._index >= this._input.length - 1) {
        return this.current = 64, !1
      }
      var a = e.codex.indexOf(this._input.charAt(++this._index)), b = e.codex.indexOf(this._input.charAt(++this._index)), c = e.codex.indexOf(this._input.charAt(++this._index)), d = e.codex.indexOf(this._input.charAt(++this._index)), m = (c & 3) << 6 | d;
      this.current = a << 2 | b >> 4;
      64 != c && this._buffer.push((b & 15) << 4 | c >> 2);
      64 != d && this._buffer.push(m);
      return!0
    }};
    return e
  }();
  var H = Ably.Crypto = window.CryptoJS && function() {
    function a() {
    }
    function c() {
      this.iv = this.key = this.algorithm = null
    }
    function b(a) {
      var b = this.algorithm = a.algorithm.toUpperCase().replace(/-\d+$/, ""), c = this.key = a.key;
      a = this.iv = a.iv;
      this.encryptCipher = CryptoJS.algo[b].createEncryptor(c, {iv:a});
      this.blockLengthWords = a.words.length
    }
    var e = w.TData, g = w.TType, f;
    if(window.Uint32Array && window.crypto && window.crypto.getRandomValues) {
      var d = new Uint32Array(4);
      f = function(a, b) {
        var c = a / 4, f = 4 == c ? d : new Uint32Array(c);
        window.crypto.getRandomValues(f);
        for(var e = Array(c), g = 0;g < c;g++) {
          e[g] = f[g]
        }
        b(null, CryptoJS.lib.WordArray.create(e))
      }
    }else {
      f = function(a, b) {
        console.log("Ably.Crypto.generateRandom(): WARNING: using insecure Math.random() to generate key or iv; see http://ably.io/documentation for how to fix this");
        for(var c = a / 4, f = Array(c), e = 0;e < c;e++) {
          f[e] = Math.floor(4294967296 * Math.random())
        }
        b(null, CryptoJS.lib.WordArray.create(f))
      }
    }
    var n = CryptoJS.lib.WordArray.create([0, 0, 0, 0]), m = [CryptoJS.lib.WordArray.create([269488144, 269488144, 269488144, 269488144], 16), CryptoJS.lib.WordArray.create([16777216], 1), CryptoJS.lib.WordArray.create([33685504], 2), CryptoJS.lib.WordArray.create([50529024], 3), CryptoJS.lib.WordArray.create([67372036], 4), CryptoJS.lib.WordArray.create([84215045, 83886080], 5), CryptoJS.lib.WordArray.create([101058054, 101056512], 6), CryptoJS.lib.WordArray.create([117901063, 117901056], 7), CryptoJS.lib.WordArray.create([134744072, 
    134744072], 8), CryptoJS.lib.WordArray.create([151587081, 151587081, 150994944], 9), CryptoJS.lib.WordArray.create([168430090, 168430090, 168427520], 10), CryptoJS.lib.WordArray.create([185273099, 185273099, 185273088], 11), CryptoJS.lib.WordArray.create([202116108, 202116108, 202116108], 12), CryptoJS.lib.WordArray.create([218959117, 218959117, 218959117, 218103808], 13), CryptoJS.lib.WordArray.create([235802126, 235802126, 235802126, 235798528], 14), CryptoJS.lib.WordArray.create([252645135, 
    252645135, 252645135, 252645135], 15), CryptoJS.lib.WordArray.create([269488144, 269488144, 269488144, 269488144], 16)];
    a.generateRandom = f;
    a.CipherParams = c;
    a.getDefaultParams = function(b, e) {
      1 == arguments.length && "function" == typeof b && (e = b, b = void 0);
      if(b) {
        "string" === typeof b ? b = CryptoJS.enc.Hex.parse(b) : b.words || (b = CryptoJS.lib.WordArray.create(b));
        var g = new c;
        g.algorithm = "aes-" + String(32 * b.words.length);
        g.key = b;
        f(16, function(a, b) {
          g.iv = b;
          e(null, g)
        })
      }else {
        f(16, function(b, c) {
          b ? e(b) : a.getDefaultParams(c, e)
        })
      }
    };
    a.CipherData = function(a, b) {
      this.cipherData = a;
      this.type = b
    };
    a.getCipher = function(e, f) {
      var g = e && e.cipherParams;
      g ? g instanceof c ? f(null, new b(g)) : f(Error("ChannelOptions not supported")) : a.getDefaultParams(function(a, c) {
        a ? f(a) : f(null, new b(c))
      })
    };
    b.prototype.encrypt = function(a) {
      h.logAction(h.LOG_MICRO, "CBCCipher.encrypt()", "");
      var b = a.sigBytes, c = b + 16 & -16, e = this.getIv().clone();
      a = this.encryptCipher.process(a.concat(m[c - b]));
      return e.concat(a)
    };
    b.prototype.decrypt = function(a) {
      h.logAction(h.LOG_MICRO, "CBCCipher.decrypt()", "");
      var b = this.blockLengthWords, c = a.words;
      a = CryptoJS.lib.WordArray.create(c.slice(0, b));
      c = CryptoJS.lib.WordArray.create(c.slice(b));
      b = CryptoJS.algo[this.algorithm].createDecryptor(this.key, {iv:a});
      a = b.process(c);
      c = b.finalize();
      b.reset();
      c && c.sigBytes && a.concat(c);
      return a
    };
    b.prototype.getIv = function() {
      if(!this.iv) {
        return this.encryptCipher.process(n)
      }
      var a = this.iv;
      this.iv = null;
      return a
    };
    var q = a.Data = {};
    q.asPlaintext = function(a) {
      var b;
      switch(a.type) {
        case g.STRING:
        ;
        case g.JSONOBJECT:
        ;
        case g.JSONARRAY:
          b = CryptoJS.enc.Utf8.parse(a.stringData);
          break;
        case g.INT32:
          b = CryptoJS.lib.WordArray.create([a.i32Data]);
          break;
        case g.INT64:
          b = CryptoJS.lib.WordArray.create([a.i64Data / 4294967296, a.i64Data % 4294967296]);
          break;
        case g.DOUBLE:
          a = a.doubleData;
          b = new ArrayBuffer(8);
          (new Float64Array(b))[0] = a;
          a = new Uint32Array(b);
          b = CryptoJS.lib.WordArray.create([a[0], a[1]]);
          break;
        case g.BUFFER:
          b = a.binaryData
      }
      return b
    };
    q.fromPlaintext = function(a, b) {
      var c = new e;
      c.type = b;
      switch(b) {
        case g.INT32:
          c.i32Data = a[0];
          break;
        case g.INT64:
          c.i64Data = 4294967296 * a[0] + a[1];
          break;
        case g.DOUBLE:
          var f;
          f = new ArrayBuffer(8);
          var d = new Uint32Array(f);
          d[0] = a.words[0];
          d[1] = a.words[1];
          f = (new Float64Array(f))[0];
          c.doubleData = f;
          break;
        case g.JSONOBJECT:
        ;
        case g.JSONARRAY:
        ;
        case g.STRING:
          c.stringData = CryptoJS.enc.Utf8.stringify(a);
          break;
        case g.BUFFER:
          c.binaryData = a
      }
      return c
    };
    q.asBase64 = function(a) {
      return CryptoJS.enc.Base64.stringify(a)
    };
    q.fromBase64 = function(a) {
      return CryptoJS.enc.Base64.parse(a)
    };
    return a
  }(), S = function() {
    function a() {
      if(!R) {
        try {
          var a = s.getElementsByTagName("body")[0].appendChild(s.createElement("span"));
          a.parentNode.removeChild(a)
        }catch(b) {
          return
        }
        R = !0;
        for(var a = D.length, c = 0;c < a;c++) {
          D[c]()
        }
      }
    }
    function c(a) {
      R ? a() : D[D.length] = a
    }
    function b(a) {
      if(typeof r.addEventListener != z) {
        r.addEventListener("load", a, !1)
      }else {
        if(typeof s.addEventListener != z) {
          s.addEventListener("load", a, !1)
        }else {
          if(typeof r.attachEvent != z) {
            Q(r, "onload", a)
          }else {
            if("function" == typeof r.onload) {
              var b = r.onload;
              r.onload = function() {
                b();
                a()
              }
            }else {
              r.onload = a
            }
          }
        }
      }
    }
    function e() {
      var a = s.getElementsByTagName("body")[0], b = s.createElement(w);
      b.setAttribute("type", x);
      var c = a.appendChild(b);
      if(c) {
        var f = 0;
        (function() {
          if(typeof c.GetVariable != z) {
            var e = c.GetVariable("$version");
            e && (e = e.split(" ")[1].split(","), p.pv = [parseInt(e[0], 10), parseInt(e[1], 10), parseInt(e[2], 10)])
          }else {
            if(10 > f) {
              f++;
              setTimeout(arguments.callee, 10);
              return
            }
          }
          a.removeChild(b);
          c = null;
          g()
        })()
      }else {
        g()
      }
    }
    function g() {
      var a = B.length;
      if(0 < a) {
        for(var b = 0;b < a;b++) {
          var c = B[b].id, e = B[b].callbackFn, g = {success:!1, id:c};
          if(0 < p.pv[0]) {
            var q = u(c);
            if(q) {
              if(V(B[b].swfVersion) && !(p.wk && 312 > p.wk)) {
                l(c, !0), e && (g.success = !0, g.ref = f(c), e(g))
              }else {
                if(B[b].expressInstall && d()) {
                  g = {};
                  g.data = B[b].expressInstall;
                  g.width = q.getAttribute("width") || "0";
                  g.height = q.getAttribute("height") || "0";
                  q.getAttribute("class") && (g.styleclass = q.getAttribute("class"));
                  q.getAttribute("align") && (g.align = q.getAttribute("align"));
                  for(var h = {}, q = q.getElementsByTagName("param"), P = q.length, F = 0;F < P;F++) {
                    "movie" != q[F].getAttribute("name").toLowerCase() && (h[q[F].getAttribute("name")] = q[F].getAttribute("value"))
                  }
                  n(g, h, c, e)
                }else {
                  m(q), e && e(g)
                }
              }
            }
          }else {
            if(l(c, !0), e) {
              if((c = f(c)) && typeof c.SetVariable != z) {
                g.success = !0, g.ref = c
              }
              e(g)
            }
          }
        }
      }
    }
    function f(a) {
      var b = null;
      if((a = u(a)) && "OBJECT" == a.nodeName) {
        typeof a.SetVariable != z ? b = a : (a = a.getElementsByTagName(w)[0]) && (b = a)
      }
      return b
    }
    function d() {
      return!J && V("6.0.65") && (p.win || p.mac) && !(p.wk && 312 > p.wk)
    }
    function n(a, b, c, e) {
      J = !0;
      K = e || null;
      M = {success:!1, id:c};
      var f = u(c);
      if(f) {
        "OBJECT" == f.nodeName ? (E = q(f), I = null) : (E = f, I = c);
        a.id = A;
        if(typeof a.width == z || !/%$/.test(a.width) && 310 > parseInt(a.width, 10)) {
          a.width = "310"
        }
        if(typeof a.height == z || !/%$/.test(a.height) && 137 > parseInt(a.height, 10)) {
          a.height = "137"
        }
        s.title = s.title.slice(0, 47) + " - Flash Player Installation";
        e = p.ie && p.win ? "ActiveX" : "PlugIn";
        e = "MMredirectURL\x3d" + r.location.toString().replace(/&/g, "%26") + "\x26MMplayerType\x3d" + e + "\x26MMdoctitle\x3d" + s.title;
        b.flashvars = typeof b.flashvars != z ? b.flashvars + ("\x26" + e) : e;
        p.ie && (p.win && 4 != f.readyState) && (e = s.createElement("div"), c += "SWFObjectNew", e.setAttribute("id", c), f.parentNode.insertBefore(e, f), f.style.display = "none", function() {
          4 == f.readyState ? f.parentNode.removeChild(f) : setTimeout(arguments.callee, 10)
        }());
        h(a, b, c)
      }
    }
    function m(a) {
      if(p.ie && p.win && 4 != a.readyState) {
        var b = s.createElement("div");
        a.parentNode.insertBefore(b, a);
        b.parentNode.replaceChild(q(a), b);
        a.style.display = "none";
        (function() {
          4 == a.readyState ? a.parentNode.removeChild(a) : setTimeout(arguments.callee, 10)
        })()
      }else {
        a.parentNode.replaceChild(q(a), a)
      }
    }
    function q(a) {
      var b = s.createElement("div");
      if(p.win && p.ie) {
        b.innerHTML = a.innerHTML
      }else {
        if(a = a.getElementsByTagName(w)[0]) {
          if(a = a.childNodes) {
            for(var c = a.length, e = 0;e < c;e++) {
              !(1 == a[e].nodeType && "PARAM" == a[e].nodeName) && 8 != a[e].nodeType && b.appendChild(a[e].cloneNode(!0))
            }
          }
        }
      }
      return b
    }
    function h(a, b, c) {
      var e, f = u(c);
      if(p.wk && 312 > p.wk) {
        return e
      }
      if(f) {
        if(typeof a.id == z && (a.id = c), p.ie && p.win) {
          var g = "", d;
          for(d in a) {
            a[d] != Object.prototype[d] && ("data" == d.toLowerCase() ? b.movie = a[d] : "styleclass" == d.toLowerCase() ? g += ' class\x3d"' + a[d] + '"' : "classid" != d.toLowerCase() && (g += " " + d + '\x3d"' + a[d] + '"'))
          }
          d = "";
          for(var m in b) {
            b[m] != Object.prototype[m] && (d += '\x3cparam name\x3d"' + m + '" value\x3d"' + b[m] + '" /\x3e')
          }
          f.outerHTML = '\x3cobject classid\x3d"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + g + "\x3e" + d + "\x3c/object\x3e";
          G[G.length] = a.id;
          e = u(a.id)
        }else {
          m = s.createElement(w);
          m.setAttribute("type", x);
          for(var t in a) {
            a[t] != Object.prototype[t] && ("styleclass" == t.toLowerCase() ? m.setAttribute("class", a[t]) : "classid" != t.toLowerCase() && m.setAttribute(t, a[t]))
          }
          for(g in b) {
            b[g] != Object.prototype[g] && "movie" != g.toLowerCase() && (a = m, d = g, t = b[g], c = s.createElement("param"), c.setAttribute("name", d), c.setAttribute("value", t), a.appendChild(c))
          }
          f.parentNode.replaceChild(m, f);
          e = m
        }
      }
      return e
    }
    function F(a) {
      var b = u(a);
      b && "OBJECT" == b.nodeName && (p.ie && p.win ? (b.style.display = "none", function() {
        if(4 == b.readyState) {
          var c = u(a);
          if(c) {
            for(var e in c) {
              "function" == typeof c[e] && (c[e] = null)
            }
            c.parentNode.removeChild(c)
          }
        }else {
          setTimeout(arguments.callee, 10)
        }
      }()) : b.parentNode.removeChild(b))
    }
    function u(a) {
      var b = null;
      try {
        b = s.getElementById(a)
      }catch(c) {
      }
      return b
    }
    function Q(a, b, c) {
      a.attachEvent(b, c);
      C[C.length] = [a, b, c]
    }
    function V(a) {
      var b = p.pv;
      a = a.split(".");
      a[0] = parseInt(a[0], 10);
      a[1] = parseInt(a[1], 10) || 0;
      a[2] = parseInt(a[2], 10) || 0;
      return b[0] > a[0] || b[0] == a[0] && b[1] > a[1] || b[0] == a[0] && b[1] == a[1] && b[2] >= a[2] ? !0 : !1
    }
    function k(a, b, c, e) {
      if(!p.ie || !p.mac) {
        var f = s.getElementsByTagName("head")[0];
        if(f) {
          c = c && "string" == typeof c ? c : "screen";
          e && (L = N = null);
          if(!N || L != c) {
            e = s.createElement("style"), e.setAttribute("type", "text/css"), e.setAttribute("media", c), N = f.appendChild(e), p.ie && (p.win && typeof s.styleSheets != z && 0 < s.styleSheets.length) && (N = s.styleSheets[s.styleSheets.length - 1]), L = c
          }
          p.ie && p.win ? N && typeof N.addRule == w && N.addRule(a, b) : N && typeof s.createTextNode != z && N.appendChild(s.createTextNode(a + " {" + b + "}"))
        }
      }
    }
    function l(a, b) {
      if(O) {
        var c = b ? "visible" : "hidden";
        R && u(a) ? u(a).style.visibility = c : k("#" + a, "visibility:" + c)
      }
    }
    function v(a) {
      return null != /[\\\"<>\.;]/.exec(a) && typeof encodeURIComponent != z ? encodeURIComponent(a) : a
    }
    var z = "undefined", w = "object", x = "application/x-shockwave-flash", A = "SWFObjectExprInst", r = window, s = document, y = navigator, H = !1, D = [function() {
      H ? e() : g()
    }], B = [], G = [], C = [], E, I, K, M, R = !1, J = !1, N, L, O = !0, p = function() {
      var a = typeof s.getElementById != z && typeof s.getElementsByTagName != z && typeof s.createElement != z, b = y.userAgent.toLowerCase(), c = y.platform.toLowerCase(), e = c ? /win/.test(c) : /win/.test(b), c = c ? /mac/.test(c) : /mac/.test(b), b = /webkit/.test(b) ? parseFloat(b.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : !1, f = !+"\v1", g = [0, 0, 0], d = null;
      if(typeof y.plugins != z && typeof y.plugins["Shockwave Flash"] == w) {
        if((d = y.plugins["Shockwave Flash"].description) && !(typeof y.mimeTypes != z && y.mimeTypes[x] && !y.mimeTypes[x].enabledPlugin)) {
          H = !0, f = !1, d = d.replace(/^.*\s+(\S+\s+\S+$)/, "$1"), g[0] = parseInt(d.replace(/^(.*)\..*$/, "$1"), 10), g[1] = parseInt(d.replace(/^.*\.(.*)\s.*$/, "$1"), 10), g[2] = /[a-zA-Z]/.test(d) ? parseInt(d.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0
        }
      }else {
        if(typeof r.ActiveXObject != z) {
          try {
            var m = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
            if(m && (d = m.GetVariable("$version"))) {
              f = !0, d = d.split(" ")[1].split(","), g = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)]
            }
          }catch(t) {
          }
        }
      }
      return{w3:a, pv:g, wk:b, ie:f, win:e, mac:c}
    }();
    (function() {
      p.w3 && ((typeof s.readyState != z && "complete" == s.readyState || typeof s.readyState == z && (s.getElementsByTagName("body")[0] || s.body)) && a(), R || (typeof s.addEventListener != z && s.addEventListener("DOMContentLoaded", a, !1), p.ie && p.win && (s.attachEvent("onreadystatechange", function() {
        "complete" == s.readyState && (s.detachEvent("onreadystatechange", arguments.callee), a())
      }), r == top && function() {
        if(!R) {
          try {
            s.documentElement.doScroll("left")
          }catch(b) {
            setTimeout(arguments.callee, 0);
            return
          }
          a()
        }
      }()), p.wk && function() {
        R || (/loaded|complete/.test(s.readyState) ? a() : setTimeout(arguments.callee, 0))
      }(), b(a)))
    })();
    (function() {
      p.ie && p.win && window.attachEvent("onunload", function() {
        for(var a = C.length, b = 0;b < a;b++) {
          C[b][0].detachEvent(C[b][1], C[b][2])
        }
        a = G.length;
        for(b = 0;b < a;b++) {
          F(G[b])
        }
        for(var c in p) {
          p[c] = null
        }
        p = null;
        for(var e in S) {
          S[e] = null
        }
        S = null
      })
    })();
    return{registerObject:function(a, b, c, e) {
      if(p.w3 && a && b) {
        var f = {};
        f.id = a;
        f.swfVersion = b;
        f.expressInstall = c;
        f.callbackFn = e;
        B[B.length] = f;
        l(a, !1)
      }else {
        e && e({success:!1, id:a})
      }
    }, getObjectById:function(a) {
      if(p.w3) {
        return f(a)
      }
    }, embedSWF:function(a, b, e, f, g, m, q, F, u, Q) {
      var k = {success:!1, id:b};
      p.w3 && !(p.wk && 312 > p.wk) && a && b && e && f && g ? (l(b, !1), c(function() {
        e += "";
        f += "";
        var c = {};
        if(u && typeof u === w) {
          for(var p in u) {
            c[p] = u[p]
          }
        }
        c.data = a;
        c.width = e;
        c.height = f;
        p = {};
        if(F && typeof F === w) {
          for(var W in F) {
            p[W] = F[W]
          }
        }
        if(q && typeof q === w) {
          for(var s in q) {
            p.flashvars = typeof p.flashvars != z ? p.flashvars + ("\x26" + s + "\x3d" + q[s]) : s + "\x3d" + q[s]
          }
        }
        if(V(g)) {
          W = h(c, p, b), c.id == b && l(b, !0), k.success = !0, k.ref = W
        }else {
          if(m && d()) {
            c.data = m;
            n(c, p, b, Q);
            return
          }
          l(b, !0)
        }
        Q && Q(k)
      })) : Q && Q(k)
    }, switchOffAutoHideShow:function() {
      O = !1
    }, ua:p, getFlashPlayerVersion:function() {
      return{major:p.pv[0], minor:p.pv[1], release:p.pv[2]}
    }, hasFlashPlayerVersion:V, createSWF:function(a, b, c) {
      if(p.w3) {
        return h(a, b, c)
      }
    }, showExpressInstall:function(a, b, c, e) {
      p.w3 && d() && n(a, b, c, e)
    }, removeSWF:function(a) {
      p.w3 && F(a)
    }, createCSS:function(a, b, c, e) {
      p.w3 && k(a, b, c, e)
    }, addDomLoadEvent:c, addLoadEvent:b, getQueryParamValue:function(a) {
      var b = s.location.search || s.location.hash;
      if(b) {
        /\?/.test(b) && (b = b.split("?")[1]);
        if(null == a) {
          return v(b)
        }
        for(var b = b.split("\x26"), c = 0;c < b.length;c++) {
          if(b[c].substring(0, b[c].indexOf("\x3d")) == a) {
            return v(b[c].substring(b[c].indexOf("\x3d") + 1))
          }
        }
      }
      return""
    }, expressInstallCallback:function() {
      if(J) {
        var a = u(A);
        a && E && (a.parentNode.replaceChild(E, a), I && (l(I, !0), p.ie && p.win && (E.style.display = "block")), K && K(M));
        J = !1
      }
    }}
  }(), $ = function() {
    window.WebSocket = window.WebSocket || {};
    logger = window.console && window.console.log && window.console.error ? window.console : {log:function() {
    }, error:function() {
    }};
    var a = function(c, b, e, g, f) {
      var d = this;
      d.__id = a.__nextId++;
      a.__instances[d.__id] = d;
      d.readyState = a.CONNECTING;
      d.bufferedAmount = 0;
      d.__events = {};
      b ? "string" == typeof b && (b = [b]) : b = [];
      d.__createTask = setTimeout(function() {
        a.__addTask(function() {
          d.__createTask = null;
          a.__flash.create(d.__id, c, b, e || null, g || 0, f || null)
        })
      }, 0)
    };
    a.prototype.send = function(c) {
      if(this.readyState == a.CONNECTING) {
        throw"INVALID_STATE_ERR: Web Socket connection has not been established";
      }
      c = a.__flash.send(this.__id, encodeURIComponent(c));
      if(0 > c) {
        return!0
      }
      this.bufferedAmount += c;
      return!1
    };
    a.prototype.close = function() {
      this.__createTask ? (clearTimeout(this.__createTask), this.__createTask = null, this.readyState = a.CLOSED) : this.readyState == a.CLOSED || this.readyState == a.CLOSING || (this.readyState = a.CLOSING, a.__flash.close(this.__id))
    };
    a.prototype.addEventListener = function(a, b, e) {
      a in this.__events || (this.__events[a] = []);
      this.__events[a].push(b)
    };
    a.prototype.removeEventListener = function(a, b, e) {
      if(a in this.__events) {
        a = this.__events[a];
        for(e = a.length - 1;0 <= e;--e) {
          if(a[e] === b) {
            a.splice(e, 1);
            break
          }
        }
      }
    };
    a.prototype.dispatchEvent = function(a) {
      for(var b = this.__events[a.type] || [], e = 0;e < b.length;++e) {
        b[e](a)
      }
      (b = this["on" + a.type]) && b.apply(this, [a])
    };
    a.prototype.__handleEvent = function(a) {
      "readyState" in a && (this.readyState = a.readyState);
      "protocol" in a && (this.protocol = a.protocol);
      var b;
      if("open" == a.type || "error" == a.type) {
        b = this.__createSimpleEvent(a.type)
      }else {
        if("close" == a.type) {
          b = this.__createSimpleEvent("close"), b.wasClean = a.wasClean ? !0 : !1, b.code = a.code, b.reason = a.reason
        }else {
          if("message" == a.type) {
            a = decodeURIComponent(a.message), b = this.__createMessageEvent("message", a)
          }else {
            throw"unknown event type: " + a.type;
          }
        }
      }
      this.dispatchEvent(b)
    };
    a.prototype.__createSimpleEvent = function(a) {
      if(document.createEvent && window.Event) {
        var b = document.createEvent("Event");
        b.initEvent(a, !1, !1);
        return b
      }
      return{type:a, bubbles:!1, cancelable:!1}
    };
    a.prototype.__createMessageEvent = function(a, b) {
      if(document.createEvent && window.MessageEvent && !window.opera) {
        var e = document.createEvent("MessageEvent");
        e.initMessageEvent("message", !1, !1, b, null, null, window, null);
        return e
      }
      return{type:a, data:b, bubbles:!1, cancelable:!1}
    };
    a.CONNECTING = 0;
    a.OPEN = 1;
    a.CLOSING = 2;
    a.CLOSED = 3;
    a.__isFlashImplementation = !0;
    a.__initialized = !1;
    a.__flash = null;
    a.__instances = {};
    a.__tasks = [];
    a.__nextId = 0;
    a.loadFlashPolicyFile = function(c) {
      a.__addTask(function() {
        a.__flash.loadManualPolicyFile(c)
      })
    };
    a.__initialize = function(c) {
      if(!a.__initialized) {
        a.__initialized = !0;
        var b = document.createElement("div");
        b.id = "webSocketContainer";
        b.style.position = "absolute";
        a.__isFlashLite() ? (b.style.left = "0px", b.style.top = "0px") : (b.style.left = "-100px", b.style.top = "-100px");
        var e = document.createElement("div");
        e.id = "webSocketFlash";
        b.appendChild(e);
        document.body.appendChild(b);
        S.embedSWF(c, "webSocketFlash", "1", "1", "10.0.0", null, null, {hasPriority:!0, swliveconnect:!0, allowScriptAccess:"always"}, null, function(a) {
          a.success || logger.error("[WebSocket] swfobject.embedSWF failed")
        })
      }
    };
    window.WebSocket.__onFlashInitialized = a.__onFlashInitialized = function() {
      setTimeout(function() {
        a.__flash = document.getElementById("webSocketFlash");
        a.__flash.setCallerUrl(location.href);
        a.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
        for(var c = 0;c < a.__tasks.length;++c) {
          a.__tasks[c]()
        }
        a.__tasks = []
      }, 0)
    };
    window.WebSocket.__onFlashEvent = a.__onFlashEvent = function() {
      setTimeout(function() {
        try {
          for(var c = a.__flash.receiveEvents(), b = 0;b < c.length;++b) {
            a.__instances[c[b].webSocketId].__handleEvent(c[b])
          }
        }catch(e) {
          logger.error(e)
        }
      }, 0);
      return!0
    };
    window.WebSocket.__log = a.__log = function(a) {
      logger.log(decodeURIComponent(a))
    };
    window.WebSocket.__error = a.__error = function(a) {
      logger.error(decodeURIComponent(a))
    };
    a.__addTask = function(c) {
      a.__flash ? c() : a.__tasks.push(c)
    };
    a.__isFlashLite = function() {
      if(!window.navigator || !window.navigator.mimeTypes) {
        return!1
      }
      var a = window.navigator.mimeTypes["application/x-shockwave-flash"];
      return!a || !a.enabledPlugin || !a.enabledPlugin.filename ? !1 : a.enabledPlugin.filename.match(/flashlite/i) ? !0 : !1
    };
    return a
  }(), r = function() {
    function a() {
      this.any = [];
      this.events = {};
      this.anyOnce = [];
      this.eventsOnce = {}
    }
    a.prototype.on = function(a, b) {
      1 == arguments.length && "function" == typeof a ? this.any.push(a) : null === a ? this.any.push(b) : (this.events[a] = this.events[a] || []).push(b)
    };
    a.prototype.off = function(a, b) {
      if(0 == arguments.length) {
        this.any = [], this.events = {}, this.anyOnce = [], this.eventsOnce = {}
      }else {
        1 == arguments.length && "function" == typeof a && (b = a, a = null);
        var e, g = -1;
        if(null === a) {
          if(b) {
            if(!(e = this.any) || -1 == (g = e.indexOf(b))) {
              if(e = this.anyOnce) {
                g = e.indexOf(b)
              }
            }
            -1 < g && e.splice(g, 1)
          }else {
            this.any = [], this.anyOnce = []
          }
        }else {
          if(b) {
            g = -1;
            if(!(e = this.events[a]) || -1 == (g = e.indexOf(b))) {
              if(e = this.eventsOnce[a]) {
                g = e.indexOf(b)
              }
            }
            -1 < g && e.splice(g, 1)
          }else {
            delete this.events[a], delete this.eventsOnce[a]
          }
        }
      }
    };
    a.prototype.listeners = function(a) {
      if(a) {
        var b = this.events[a] || [];
        this.eventsOnce[a] && Array.prototype.push.apply(b, this.eventsOnce[a]);
        return b.length ? b : null
      }
      return this.any.length ? this.any : null
    };
    a.prototype.emit = function(a) {
      var b = Array.prototype.slice.call(arguments, 1), e = {event:a};
      if(this.anyOnce.length) {
        var g = this.anyOnce;
        this.anyOnce = [];
        for(var f = 0;f < g.length;f++) {
          g[f].apply(e, b)
        }
      }
      for(f = 0;f < this.any.length;f++) {
        this.any[f].apply(e, b)
      }
      if(g = this.eventsOnce[a]) {
        delete this.eventsOnce[a];
        for(f = 0;f < g.length;f++) {
          g[f].apply(e, b)
        }
      }
      if(g = this.events[a]) {
        for(f = 0;f < g.length;f++) {
          g[f].apply(e, b)
        }
      }
    };
    a.prototype.once = function(a, b) {
      1 == arguments.length && "function" == typeof a ? this.anyOnce.push(a) : null === a ? this.anyOnce.push(b) : (this.eventsOnce[a] = this.eventsOnce[a] || []).push(b)
    };
    return a
  }(), h = function() {
    function a(a) {
    }
    var c = 4, b = function() {
    };
    a.LOG_NONE = 0;
    a.LOG_ERROR = 1;
    a.LOG_MAJOR = 2;
    a.LOG_MINOR = 3;
    a.LOG_MICRO = 4;
    a.LOG_DEFAULT = 3;
    a.LOG_DEBUG = 4;
    a.logAction = function(a, g, f) {
      a <= c && b("Ably: " + g + ": " + f)
    };
    a.setLog = function(a, g) {
      c = a || 3;
      b = g || console.log.bind(console)
    };
    return a
  }(), k = function() {
    function a() {
    }
    var c = "object" == typeof window;
    a.addProperties = a.mixin = function(a, c) {
      for(var g in c) {
        a[g] = c[g]
      }
      return a
    };
    a.copy = function(b) {
      return a.mixin({}, b)
    };
    a.isArray = function(a) {
      return"[object Array]" == Object.prototype.toString.call(a)
    };
    a.isEmpty = function(a) {
      for(var c in a) {
        return!1
      }
      return!0
    };
    a.shallowClone = function(a) {
      var c = {}, g;
      for(g in a) {
        c[g] = a[g]
      }
      return c
    };
    a.prototypicalClone = function(b, c) {
      function g() {
      }
      g.prototype = b;
      var f = new g;
      c && a.mixin(f, c);
      return f
    };
    a.inherits = function(a, c) {
      a.super_ = c;
      a.prototype = Object.create(c.prototype, {constructor:{value:a, enumerable:!1, writable:!0, configurable:!0}})
    };
    a.containsValue = function(a, c) {
      for(var g in a) {
        if(a[g] == c) {
          return!0
        }
      }
      return!1
    };
    a.intersect = function(b, c) {
      return Array.isArray(c) ? a.arrIntersect(b, c) : a.arrIntersectOb(b, c)
    };
    a.arrIntersect = function(a, c) {
      for(var g = [], f = 0;f < a.length;f++) {
        var d = a[f];
        -1 != c.indexOf(d) && g.push(d)
      }
      return g
    };
    a.arrIntersectOb = function(a, c) {
      for(var g = [], f = 0;f < a.length;f++) {
        var d = a[f];
        d in c && g.push(d)
      }
      return g
    };
    a.arrSubtract = function(a, c) {
      for(var g = [], f = 0;f < a.length;f++) {
        var d = a[f];
        -1 == c.indexOf(d) && g.push(d)
      }
      return g
    };
    a.keysArray = function(a, c) {
      var g = [], f;
      for(f in a) {
        (!c || a.hasOwnProperty(f)) && g.push(f)
      }
      return g.length ? g : void 0
    };
    a.valuesArray = function(a, c) {
      var g = [], f;
      for(f in a) {
        (!c || a.hasOwnProperty(f)) && g.push(a[f])
      }
      return g.length ? g : void 0
    };
    a.nextTick = c ? function(a) {
      setTimeout(a, 0)
    } : process.nextTick;
    a.defaultGetHeaders = function(a) {
      return{accept:a ? "application/x-thrift,application/json" : "application/json"}
    };
    a.defaultPostHeaders = function(a) {
      return{accept:a ? "application/x-thrift,application/json" : "application/json", "content-type":a ? "application/x-thrift" : "application/json"}
    };
    a.arrRandomElement = function(a) {
      return a.splice(Math.floor(Math.random() * a.length))
    };
    a.parseQueryString = function(a) {
      for(var c, g = /([^&=]+)=?([^&]*)/g, f = {};c = g.exec(a);) {
        f[decodeURIComponent(c[1])] = decodeURIComponent(c[2])
      }
      return f
    };
    return a
  }(), aa = function() {
    function a(a) {
      a = a || [];
      var b = function(b, g) {
        for(var f = 0;f < a.length;f++) {
          try {
            a[f](b, g)
          }catch(d) {
          }
        }
      };
      b.__proto__ = this.__proto__;
      b.members = a;
      return b
    }
    k.inherits(a, Function);
    a.prototype.push = function() {
      Array.prototype.push.apply(this.members, arguments)
    };
    return a
  }(), y = function() {
    function a(a, b, c, f, e) {
      this.options = a;
      this.binary = !a.useTextProtocol;
      this.host = b;
      this.mode = c;
      this.connectionId = f;
      this.connectionSerial = e
    }
    function c(a, b) {
      this.msg = a;
      var c = a.action;
      this.ackRequired = c == f.MESSAGE || c == f.PRESENCE;
      this.callback = b;
      this.merged = !1
    }
    function b(a, c) {
      r.call(this);
      this.realtime = a;
      this.options = c;
      this.state = n.initialized;
      this.error = null;
      this.queuedMessages = [];
      this.pendingMessages = [];
      this.msgSerial = 0;
      this.connectionSerial = this.connectionId = void 0;
      this.httpTransports = k.intersect(c.transports || v.httpTransports, b.httpTransports);
      this.transports = k.intersect(c.transports || v.transports, b.transports);
      this.upgradeTransports = k.arrSubtract(this.transports, this.httpTransports);
      this.httpHosts = v.getHosts(c);
      this.host = this.pendingTransport = this.transport = null;
      h.logAction(h.LOG_MINOR, "Realtime.ConnectionManager()", "started");
      h.logAction(h.LOG_MICRO, "Realtime.ConnectionManager()", "requested transports \x3d [" + (c.transports || v.transports) + "]");
      h.logAction(h.LOG_MICRO, "Realtime.ConnectionManager()", "available http transports \x3d [" + this.httpTransports + "]");
      h.logAction(h.LOG_MICRO, "Realtime.ConnectionManager()", "available transports \x3d [" + this.transports + "]");
      h.logAction(h.LOG_MICRO, "Realtime.ConnectionManager()", "http hosts \x3d [" + this.httpHosts + "]");
      if(!this.transports.length) {
        throw h.logAction(h.LOG_ERROR, "realtime.ConnectionManager()", "no requested transports available"), Error("no requested transports available");
      }
      g && c.recover && window.addEventListener("beforeunload", function() {
        self.persistConnection()
      })
    }
    var e = "undefined" !== typeof Cookie && Cookie.read, g = "undefined" !== typeof Cookie && Cookie.create, f = ("object" == typeof w ? w : require("../nodejs/lib/protocol/clientmessage_types")).TAction, d = function() {
    }, n = {initialized:{state:"initialized", terminal:!1, queueEvents:!0, sendEvents:!1}, connecting:{state:"connecting", terminal:!1, queueEvents:!0, sendEvents:!1, retryDelay:v.connectTimeout, failState:"disconnected"}, connected:{state:"connected", terminal:!1, queueEvents:!1, sendEvents:!0, failState:"disconnected"}, disconnected:{state:"disconnected", terminal:!1, queueEvents:!0, sendEvents:!1, retryDelay:v.disconnectTimeout}, suspended:{state:"suspended", terminal:!1, queueEvents:!1, sendEvents:!1, 
    retryDelay:v.suspendedTimeout}, closed:{state:"closed", terminal:!1, queueEvents:!1, sendEvents:!1}, failed:{state:"failed", terminal:!0, queueEvents:!1, sendEvents:!1}};
    a.prototype.getConnectParams = function(a) {
      a = a ? k.prototypicalClone(a) : {};
      var b = this.options;
      switch(this.mode) {
        case "resume":
          a.resume = this.connectionId;
          void 0 !== this.connectionSerial && (a.connection_serial = this.connectionSerial);
          break;
        case "recover":
          if(!0 === b.recover) {
            a.recover = e("ably-connection-id"), a.connection_serial = e("ably-connection-serial")
          }else {
            var c = b.recover.match(/^(\w+):(\w+)$/);
            c && (a.recover = c[1], a.connection_serial = c[2])
          }
      }
      !1 === b.echoMessages && (a.echoMessages = "false");
      a.binary = this.binary;
      a.timestamp = Date.now();
      return a
    };
    k.inherits(b, r);
    b.httpTransports = {};
    b.transports = {};
    b.prototype.chooseTransport = function(b) {
      h.logAction(h.LOG_MAJOR, "ConnectionManager.chooseTransport()", "");
      if(this.transport) {
        h.logAction(h.LOG_MINOR, "ConnectionManager.chooseTransport()", "Transport already established"), b(null, this.transport)
      }else {
        var c = this.connectionId ? "resume" : this.options.recover ? "recover" : "clean", f = new a(this.options, null, c, this.connectionId, this.connectionSerial);
        h.logAction(h.LOG_MINOR, "ConnectionManager.chooseTransport()", "Transport recovery mode \x3d " + c + ("clean" == c ? "" : "; connectionId \x3d " + this.connectionId + "; connectionSerial \x3d " + this.connectionSerial));
        var e = this;
        this.httpTransports.length ? this.chooseHttpTransport(f, function(c, g) {
          if(c) {
            h.logAction(h.LOG_ERROR, "ConnectionManager.chooseTransport()", "Unexpected error establishing transport; err \x3d " + c), b(c)
          }else {
            if(h.logAction(h.LOG_MINOR, "ConnectionManager.chooseTransport()", "Establishing http transport: " + g), b(null, g), e.upgradeTransports.length) {
              g.on("connected", function(b, c) {
                h.logAction(h.LOG_MAJOR, "ConnectionManager.chooseTransport()", "upgrading ... connectionId \x3d " + c);
                f = new a(e.options, f.host, "resume", c, e.connectionSerial);
                e.chooseTransportForHost(f, e.upgradeTransports.slice(), d)
              })
            }
          }
        }) : (f.host = this.httpHosts[0], h.logAction(h.LOG_MINOR, "ConnectionManager.chooseTransport()", "No http transports available; ignoring fallback hosts"), this.chooseTransportForHost(f, e.transports.slice(), b))
      }
    };
    b.prototype.chooseTransportForHost = function(a, c, f) {
      var e = c.shift();
      if(e) {
        var g = this;
        h.logAction(h.LOG_MICRO, "ConnectionManager.chooseTransportForHost()", "trying " + e);
        b.transports[e].tryConnect(this, this.realtime.auth, a, function(b, d) {
          b ? g.chooseTransportForHost(a, c, f) : (h.logAction(h.LOG_MICRO, "ConnectionManager.chooseTransport()", "transport " + e + " connecting"), g.setTransportPending(d), f(null, d))
        })
      }else {
        var d = Error("Unable to connect (no available transport)");
        d.statusCode = 404;
        d.code = 8E4;
        f(d)
      }
    };
    b.prototype.chooseHttpTransport = function(a, c) {
      function f() {
        if(e.length) {
          b.httpTransports[d.httpTransports[0]].checkConnectivity(function(b, g) {
            b ? c(b) : g ? (a.host = k.arrRandomElement(e), d.chooseTransportForHost(a, d.httpTransports.slice(), function(a, b) {
              a ? f() : c(null, b)
            })) : (b = Error("Unable to connect (network unreachable)"), b.statusCode = 404, b.code = 8E4, c(b))
          })
        }else {
          var g = Error("Unable to connect (no available host)");
          g.statusCode = 404;
          g.code = 8E4;
          c(g)
        }
      }
      var e = this.httpHosts.slice(), g = e.shift();
      if(g) {
        a.host = g;
        var d = this;
        this.chooseTransportForHost(a, this.httpTransports.slice(), function(a, b) {
          a ? f() : c(null, b)
        })
      }else {
        g = Error("Unable to connect (no available host)"), g.statusCode = 404, g.code = 8E4, c(g)
      }
    };
    b.prototype.setTransportPending = function(a) {
      h.logAction(h.LOG_MINOR, "ConnectionManager.setTransportPending()", "transport \x3d " + a);
      if(this.state == n.closed) {
        a.close(!0)
      }else {
        this.pendingTransport && this.pendingTransport.close(!1);
        this.pendingTransport = a;
        for(var b = this, c = function(c) {
          return function(f, e) {
            h.logAction(h.LOG_MINOR, "ConnectionManager.setTransportPending", "on state \x3d " + c);
            f && f.reason && h.logAction(h.LOG_MICRO, "ConnectionManager.setTransportPending", "reason \x3d  " + f.reason);
            e && h.logAction(h.LOG_MICRO, "ConnectionManager.setTransportPending", "connectionId \x3d  " + e);
            var g;
            "connected" == c ? (b.activateTransport(a, e), g = !0) : g = b.deactivateTransport(a);
            g && b.notifyState({state:c, error:f})
          }
        }, f = ["connected", "disconnected", "closed", "failed"], e = 0;e < f.length;e++) {
          var g = f[e];
          a.on(g, c(g))
        }
        this.emit("transport.pending", a)
      }
    };
    b.prototype.activateTransport = function(a, b) {
      h.logAction(h.LOG_MINOR, "ConnectionManager.activateTransport()", "transport \x3d " + a + "; connectionId \x3d " + b);
      if(this.state != n.closed) {
        var c = this.transport;
        c && (this.transport = null, c.close(!1));
        if(c = this.pendingTransport) {
          this.pendingTransport = null
        }
        this.transport = a;
        this.host = a.params.host;
        b && this.connectionId != b && (this.realtime.connection.id = this.connectionId = b, this.msgSerial = 0);
        var f = this;
        a.on("ack", function(a, b) {
          h.logAction(h.LOG_MICRO, "ConnectionManager on(ack)", "serial \x3d " + a + "; count \x3d " + b);
          f.ackMessage(a, b)
        });
        a.on("nack", function(a, b, c) {
          h.logAction(h.LOG_ERROR, "ConnectionManager on(nack)", "serial \x3d " + a + "; count \x3d " + b + "; err \x3d " + c);
          c || (c = Error("Unknown error"), c.statusCode = 500, c.code = 50001, c.reason = "Unable to send message; channel not responding");
          f.ackMessage(a, b, c)
        });
        this.emit("transport.active", a, b, a.params)
      }
    };
    b.prototype.deactivateTransport = function(a) {
      var b = this.transport === a;
      h.logAction(h.LOG_MINOR, "ConnectionManager.deactivateTransport()", "transport \x3d " + a);
      a.off("ack");
      a.off("nack");
      b ? this.transport = this.host = null : this.pendingTransport === a && (this.pendingTransport = null);
      this.emit("transport.inactive", a);
      return b
    };
    b.prototype.persistConnection = function() {
      g && (this.connectionId && g("ably-connection-id", this.connectionId), this.connectionSerial && g("ably-connection-serial", this.connectionSerial))
    };
    b.prototype.getStateError = function() {
      return D[this.state.state]
    };
    b.activeState = function(a) {
      return a.queueEvents || a.sendEvents
    };
    b.prototype.enactStateChange = function(a) {
      h.logAction(h.LOG_MINOR, "ConnectionManager.enactStateChange", "setting new state: " + a.current);
      this.state = n[a.current];
      this.state.terminal && (this.error = a.reason);
      this.emit("connectionstate", a, this.transport)
    };
    b.prototype.startConnectTimer = function() {
      var a = this;
      this.connectTimer = setTimeout(function() {
        a.connectTimer && (h.logAction(h.LOG_MINOR, "ConnectionManager connect timer expired", "requesting new state: " + n.connecting.failState), a.notifyState({state:n.connecting.failState}))
      }, v.connectTimeout)
    };
    b.prototype.cancelConnectTimer = function() {
      this.connectTimer && (clearTimeout(this.connectTimer), this.connectTimer = void 0)
    };
    b.prototype.startSuspendTimer = function() {
      var a = this;
      this.suspendTimer || (this.suspendTimer = setTimeout(function() {
        a.suspendTimer && (h.logAction(h.LOG_MINOR, "ConnectionManager suspend timer expired", "requesting new state: suspended"), n.connecting.failState = "suspended", n.connecting.queueEvents = !1, a.notifyState({state:"suspended"}))
      }, v.suspendedTimeout))
    };
    b.prototype.cancelSuspendTimer = function() {
      n.connecting.failState = "disconnected";
      n.connecting.queueEvents = !0;
      this.suspendTimer && (clearTimeout(this.suspendTimer), delete this.suspendTimer)
    };
    b.prototype.startRetryTimer = function(a) {
      var b = this;
      this.retryTimer = setTimeout(function() {
        h.logAction(h.LOG_MINOR, "ConnectionManager retry timer expired", "retrying");
        b.requestState({state:"connecting"})
      }, a)
    };
    b.prototype.cancelRetryTimer = function() {
      this.retryTimer && (clearTimeout(this.retryTimer), delete this.retryTimer)
    };
    b.prototype.notifyState = function(a) {
      if(!(this.state.terminal || a.state == this.state.state)) {
        h.logAction(h.LOG_MINOR, "ConnectionManager.notifyState()", "new state: " + a.state);
        var b = n[a.state];
        !b.sendEvents && this.transport && (h.logAction(h.LOG_MINOR, "ConnectionManager.notifyState()", "deleting transport " + this.transport), this.transport.dispose(), delete this.transport);
        this.cancelConnectTimer();
        this.cancelRetryTimer();
        "connected" == a.state && this.cancelSuspendTimer();
        a = new ba(this.state.state, b.state, b.retryDelay, a.error || D[b.state]);
        b.retryDelay && this.startRetryTimer(b.retryDelay);
        this.enactStateChange(a);
        this.state.sendEvents ? this.sendQueuedMessages() : this.state.queueEvents ? this.queuePendingMessages() : this.realtime.channels.setSuspended(a.reason)
      }
    };
    b.prototype.requestState = function(a) {
      this.cancelConnectTimer();
      this.cancelRetryTimer();
      if(a.state != this.state.state) {
        if(this.state.terminal) {
          throw Error(this.error);
        }
        if("connecting" == a.state) {
          if("connected" == this.state.state) {
            return
          }
          this.connectImpl()
        }else {
          this.pendingTransport && (this.pendingTransport.close(!0), this.pendingTransport = null), "failed" == a.state ? this.transport && (this.transport.abort(a.reason), this.transport = null) : (a.state = "closed", this.cancelConnectTimer(), this.cancelRetryTimer(), this.cancelSuspendTimer(), this.transport && (this.transport.close(!0), this.transport = null))
        }
        if(a.state != this.state.state) {
          var b = n[a.state];
          a = new ba(this.state.state, b.state, b.retryIn, a.error || D[b.state]);
          this.enactStateChange(a)
        }
      }
    };
    b.prototype.connectImpl = function() {
      h.logAction(h.LOG_MINOR, "ConnectionManager.connectImpl()", "starting connection");
      this.startSuspendTimer();
      this.startConnectTimer();
      var a = this, b = this.realtime.auth, c = function(f) {
        h.logAction(h.LOG_ERROR, "ConnectionManager.connectImpl()", f);
        401 == f.statusCode && (-1 != f.message.indexOf("expire") && "token" == b.method) && b.getToken(!0, function(b) {
          b ? c(b) : a.connectImpl()
        });
        a.notifyState({state:n.connecting.failState, error:f})
      }, f = function() {
        a.chooseTransport(function(a, b) {
          a && c(a)
        })
      };
      "basic" == b.method ? f() : b.authorise(null, null, function(a) {
        a ? c(a) : f()
      })
    };
    b.prototype.send = function(a, b, f) {
      f = f || d;
      var e = this.state;
      e.sendEvents ? (h.logAction(h.LOG_MICRO, "ConnectionManager.send()", "sending event"), this.sendImpl(new c(a, f))) : e.queueEvents && (b ? this.queue(a, f) : (h.logAction(h.LOG_MICRO, "ConnectionManager.send()", "rejecting event"), f(this.error)))
    };
    b.prototype.sendImpl = function(a) {
      var b = a.msg;
      a.ackRequired && (b.msgSerial = this.msgSerial++, this.pendingMessages.push(a));
      try {
        this.transport.send(b, function(a) {
        })
      }catch(c) {
        h.logAction(h.LOG_ERROR, "ConnectionManager.sendQueuedMessages()", "Unexpected exception in transport.send(): " + c)
      }
    };
    b.prototype.ackMessage = function(a, b, c) {
      h.logAction(h.LOG_MICRO, "ConnectionManager.ackMessage()", "serial \x3d " + a + "; count \x3d " + b);
      c = c || null;
      var f = this.pendingMessages, e = f[0];
      if(e && (e = e.msg.msgSerial, a += b, a > e)) {
        f = f.splice(0, a - e);
        for(a = 0;a < f.length;a++) {
          f[a].callback(c)
        }
      }
    };
    b.prototype.queue = function(a, b) {
      h.logAction(h.LOG_MICRO, "ConnectionManager.queue()", "queueing event");
      var f = this.queuedMessages[this.queuedMessages.length - 1];
      f && fa.mergeTo(f.msg, a) ? (f.merged || (f.callback = new aa([f.callback]), f.merged = !0), f.callback.push(b)) : this.queuedMessages.push(new c(a, b))
    };
    b.prototype.sendQueuedMessages = function() {
      h.logAction(h.LOG_MICRO, "ConnectionManager.sendQueuedMessages()", "sending " + this.queuedMessages.length + " queued messages");
      for(var a;a = this.queuedMessages.shift();) {
        this.sendImpl(a)
      }
    };
    b.prototype.queuePendingMessages = function() {
      h.logAction(h.LOG_MICRO, "ConnectionManager.queuePendingMessages()", "queueing " + this.pendingMessages.length + " pending messages");
      this.queuedMessages = this.pendingMessages.concat(this.queuedMessages);
      this.pendingMessages = []
    };
    b.prototype.onChannelMessage = function(a, b) {
      b === this.transport && (this.connectionSerial = a.connectionSerial, this.realtime.channels.onChannelMessage(a))
    };
    return b
  }(), G = function() {
    function a(a, c, g) {
      r.call(this);
      this.connectionManager = a;
      this.auth = c;
      this.params = g;
      this.isConnected = !1
    }
    var c = ("object" == typeof window ? w : require("../nodejs/lib/protocol/clientmessage_types")).TAction;
    k.inherits(a, r);
    a.prototype.connect = function() {
    };
    a.prototype.close = function(a) {
      this.isConnected = !1;
      this.emit("closed", D.closed);
      this.sendClose(a);
      this.dispose()
    };
    a.prototype.abort = function(a) {
      this.isConnected = !1;
      this.emit("failed", a);
      this.sendClose(!0);
      this.dispose()
    };
    a.prototype.onChannelMessage = function(a) {
      switch(a.action) {
        case c.HEARTBEAT:
          this.emit("heartbeat");
          break;
        case c.CONNECTED:
          this.onConnect(a);
          this.emit("connected", null, this.connectionId, a.flags);
          break;
        case c.CLOSED:
        ;
        case c.DISCONNECTED:
          this.isConnected = !1;
          this.onDisconnect();
          break;
        case c.ACK:
          this.emit("ack", a.msgSerial, a.count);
          break;
        case c.NACK:
          this.emit("nack", a.msgSerial, a.count, a.error);
          break;
        case c.ERROR:
          if(!a.channel) {
            a = a.error;
            this.abort({statusCode:a.statusCode, code:a.code, reason:a.reason});
            break
          }
        ;
        default:
          this.connectionManager.onChannelMessage(a, this)
      }
    };
    a.prototype.onConnect = function(a) {
      this.connectionId = a.connectionId;
      this.isConnected = !0
    };
    a.prototype.onDisconnect = function() {
    };
    a.prototype.onClose = function(a, c) {
      if("closed" != this.connectionManager.state.state) {
        var g = a ? "disconnected" : "failed";
        this.isConnected = !1;
        var f = k.copy(D[g]);
        c && (f.reason = c);
        this.emit(g, f)
      }
    };
    a.prototype.dispose = function() {
      this.off()
    };
    return a
  }(), ga = function() {
    function a(a, b, c) {
      c.binary = c.binary && g;
      G.call(this, a, b, c);
      this.wsHost = v.getHost(c.options, c.host, !0)
    }
    var c = "object" == typeof window, b = c ? w : require("../nodejs/lib/protocol/clientmessage_types"), e = c ? window.WebSocket || window.MozWebSocket : require("ws"), g = c ? !1 : !!A, f = function() {
    };
    k.inherits(a, G);
    a.isAvailable = function() {
      return!!e
    };
    a.isAvailable() && (y.transports.web_socket = a);
    a.tryConnect = function(b, c, f, e) {
      var g = new a(b, c, f), d = function(a) {
        e(a)
      };
      g.on("wserror", d);
      g.on("wsopen", function() {
        h.logAction(h.LOG_MINOR, "WebSocketTransport.tryConnect()", "viable transport " + g);
        g.off("wserror", d);
        e(null, g)
      });
      g.connect()
    };
    a.prototype.createWebSocket = function(a, b) {
      var c = 0;
      if(b) {
        for(var f in b) {
          a += (c++ ? "\x26" : "?") + f + "\x3d" + b[f]
        }
      }
      this.uri = a;
      return new e(a)
    };
    a.prototype.toString = function() {
      return"WebSocketTransport; uri\x3d" + this.uri
    };
    a.prototype.connect = function() {
      h.logAction(h.LOG_MINOR, "WebSocketTransport.connect()", "starting");
      G.prototype.connect.call(this);
      var a = this, b = this.params, c = b.options, f = (c.tls ? "wss://" : "ws://") + this.wsHost + ":" + v.getPort(c) + "/";
      h.logAction(h.LOG_MINOR, "WebSocketTransport.connect()", "uri: " + f);
      this.auth.getAuthParams(function(c, e) {
        var g = "", d;
        for(d in e) {
          g += " " + d + ": " + e[d] + ";"
        }
        h.logAction(h.LOG_MINOR, "WebSocketTransport.connect()", "authParams:" + g);
        if(c) {
          a.abort(UIMessages.FAIL_REASON_REFUSED)
        }else {
          g = b.getConnectParams(e);
          try {
            var m = a.wsConnection = a.createWebSocket(f, g);
            m.binaryType = "arraybuffer";
            m.onopen = function() {
              a.onWsOpen()
            };
            m.onclose = function(b, c) {
              a.onWsClose(b, c)
            };
            m.onmessage = function(b) {
              a.onWsData(b.data, "string" != typeof b.data)
            };
            m.onerror = function(b) {
              a.onWsError(b)
            }
          }catch(k) {
            a.onWsError(k)
          }
        }
      })
    };
    a.prototype.send = function(a, b) {
      try {
        this.wsConnection.send(Serialize.TProtocolMessage.encode(a, this.params.binary))
      }catch(c) {
        var f = "Unexpected send exception: " + c;
        h.logAction(h.LOG_ERROR, "WebSocketTransport.send()", f);
        b(Error(f))
      }
    };
    a.prototype.sendClose = function(a) {
      a && this.send(new b.TProtocolMessage({action:b.TAction.CLOSE}), f)
    };
    a.prototype.onWsData = function(a, b) {
      h.logAction(h.LOG_MICRO, "WebSocketTransport.onWsData()", "data received; length \x3d " + a.length + "; type \x3d " + typeof a + "; binary \x3d " + b);
      try {
        this.onChannelMessage(Serialize.TProtocolMessage.decode(a, b))
      }catch(c) {
        h.logAction(h.LOG_ERROR, "WebSocketTransport.onWsData()", "Unexpected exception handing channel message: " + c.stack)
      }
    };
    a.prototype.onWsOpen = function() {
      h.logAction(h.LOG_MINOR, "WebSocketTransport.onWsOpen()", "opened WebSocket");
      this.emit("wsopen")
    };
    a.prototype.onWsClose = function(a, b) {
      var c, f, e;
      "object" == typeof a ? (c = a.wasClean, f = a.code, e = a.reason) : (f = a, e = b || "", c = 1E3 == f);
      h.logAction(h.LOG_MINOR, "WebSocketTransport.onWsClose()", "closed WebSocket; wasClean \x3d " + c + "; code \x3d " + f);
      delete this.wsConnection;
      G.prototype.onClose.call(this, c, e)
    };
    a.prototype.onWsError = function(a) {
      h.logAction(h.LOG_ERROR, "WebSocketTransport.onError()", "Unexpected error from WebSocket: " + a);
      this.emit("wserror", a);
      this.abort()
    };
    a.prototype.dispose = function() {
      this.wsConnection && (this.wsConnection.close(), delete this.wsConnection)
    };
    return a
  }(), O = function() {
    function a(a, b, e) {
      G.call(this, a, b, e);
      this.binary = this.params.binary;
      this.pendingItems = this.pendingCallback = this.recvRequest = this.sendRequest = null
    }
    "object" == typeof w || require("../nodejs/lib/protocol/clientmessage_types");
    (k || require("util")).inherits(a, G);
    a.paramStr = function(a, b) {
      var e = 0, g = b || "";
      if(a) {
        for(var f in a) {
          g += (e++ ? "\x26" : "?") + f + "\x3d" + a[f]
        }
      }
      return g
    };
    a.prototype.connect = function() {
      h.logAction(h.LOG_MINOR, "CometTransport.connect()", "starting");
      G.prototype.connect.call(this);
      var c = this, b = this.params, e = b.options, b = v.getHost(e, b.host), g = v.getPort(e);
      this.baseUri = (e.tls ? "https://" : "http://") + b + ":" + g + "/comet/";
      var f = this.baseUri + "connect";
      h.logAction(h.LOG_MINOR, "CometTransport.connect()", "uri: " + f);
      this.auth.getAuthParams(function(b, e) {
        if(b) {
          c.abort(UIMessages.FAIL_REASON_REFUSED)
        }else {
          c.authParams = e;
          var g = c.params.getConnectParams(e);
          h.logAction(h.LOG_MINOR, "CometTransport.connect()", "connectParams:" + a.paramStr(g));
          try {
            c.request(f, g, null, !1, function(a, b) {
              a ? c.emit("error", a) : (c.emit("preconnect"), c.onResponseData(b))
            })
          }catch(d) {
            c.emit("error", d)
          }
        }
      })
    };
    a.prototype.sendClose = function(a) {
      if(this.closeUri) {
        var b = this;
        this.request(this.closeUri(a), this.authParams, null, !1, function(a, c) {
          a && b.emit("error", a)
        })
      }
    };
    a.prototype.dispose = function() {
      this.recvRequest && (this.recvRequest.abort(), this.recvRequest = null)
    };
    a.prototype.onConnect = function(a) {
      var b = a.connectionId;
      a.connectionId = b.split("-").pop();
      G.prototype.onConnect.call(this, a);
      var e = this.baseUri + b;
      h.logAction(h.LOG_MICRO, "CometTransport.onConnect()", "baseUri \x3d " + e + "; connectionId \x3d " + a.connectionId);
      this.sendUri = e + "/send";
      this.recvUri = e + "/recv";
      this.closeUri = function(a) {
        return e + (a ? "/close" : "/disconnect")
      };
      this.recv()
    };
    a.prototype.send = function(a, b) {
      if(this.sendRequest) {
        this.pendingItems = this.pendingItems || [], this.pendingItems.push(a), this.pendingCallback = this.pendingCallback || new aa, this.pendingCallback.push(b)
      }else {
        var e = this.pendingItems || [];
        e.push(a);
        this.pendingItems = null;
        var g = this.pendingCallback;
        g && (g.push(b), b = g, this.pendingCallback = null);
        this.sendItems(e, b)
      }
    };
    a.prototype.sendItems = function(a, b) {
      var e = this;
      try {
        this.sendRequest = e.request(e.sendUri, e.authParams, this.encodeRequest(a), !1, function(a, c) {
          e.sendRequest = null;
          e.pendingItems && (e.sendItems(e.pendingItems, e.pendingCallback), e.pendingItems = null, e.pendingCallback = null);
          a ? b(a) : (e.onResponseData(c), b(null))
        })
      }catch(g) {
        var f = "Unexpected send exception: " + g;
        h.logAction(h.LOG_ERROR, "CometTransport.sendItems()", f);
        b(Error(f))
      }
    };
    a.prototype.recv = function() {
      this.recvRequest && (this.recvRequest.abort(), this.recvRequest = null);
      if(this.isConnected) {
        var a = this;
        this.recvRequest = this.request(this.recvUri, this.authParams, null, !0, function(b, e) {
          b ? a.emit("error", b) : (a.onRecvResponse(e), a.recvRequest = null, a.recv())
        })
      }
    };
    a.prototype.onResponseData = function(a) {
      try {
        var b = this.decodeResponse(a);
        if(b && b.length) {
          for(a = 0;a < b.length;a++) {
            this.onChannelMessage(b[a])
          }
        }
      }catch(e) {
        h.logAction(h.LOG_ERROR, "CometTransport.onResponseData()", "Unexpected exception handing channel event: " + e.stack)
      }
    };
    a.prototype.onRecvResponse = function(a) {
      this.onResponseData(a)
    };
    a.prototype.encodeRequest = function(a) {
      return Serialize.TMessageBundle.encode(a, this.binary)
    };
    a.prototype.decodeResponse = function(a) {
      return Serialize.TMessageBundle.decode(a, this.binary)
    };
    return a
  }();
  this.Data = function() {
    function a() {
    }
    var c = "object" == typeof w ? w : require("../nodejs/lib/protocol/clientmessage_types"), b = "object" === typeof window, e = {"[object Null]":function(a, b) {
      a.type = c.TType.NONE;
      return!0
    }, "[object Buffer]":function(a, b) {
      a.type = c.TType.BUFFER;
      a.binaryData = b;
      return!0
    }, "[object ArrayBuffer]":function(a, b) {
      a.type = c.TType.BUFFER;
      a.binaryData = b;
      return!0
    }, "[object Array]":function(a, b) {
      a.type = c.TType.JSONARRAY;
      a.stringData = JSON.stringify(b);
      return!0
    }, "[object String]":function(a, b) {
      a.type = c.TType.STRING;
      a.stringData = b.valueOf();
      return!0
    }, "[object Number]":function(a, b) {
      a.type = c.TType.DOUBLE;
      a.doubleData = b.valueOf();
      return!0
    }, "[object Boolean]":function(a, b) {
      a.type = b.valueOf() ? c.TType.TRUE : c.TType.FALSE;
      return!0
    }, "[object Object]":function(a, e) {
      !b && A.isBuffer(e) ? (a.type = c.TType.BUFFER, a.binaryData = e) : (a.type = c.TType.JSONOBJECT, a.stringData = JSON.stringify(e));
      return!0
    }, "[object Function]":function(a, b) {
      a.type = c.TType.JSONOBJECT;
      a.stringData = JSON.stringify(b);
      return!0
    }}, g = {undefined:function(a, b) {
      a.type = c.TType.NONE;
      return!0
    }, "boolean":function(a, b) {
      a.type = b ? c.TType.TRUE : c.TType.FALSE;
      return!0
    }, string:function(a, b) {
      a.type = c.TType.STRING;
      a.stringData = b;
      return!0
    }, number:function(a, b) {
      a.type = c.TType.DOUBLE;
      a.doubleData = b;
      return!0
    }, object:function(a, b) {
      var c = e[Object.prototype.toString.call(b)];
      return c && c(a, b)
    }};
    a.isCipherData = function(a) {
      return a.cipherData
    };
    a.fromTData = function(a) {
      var b = void 0;
      if(a) {
        if(a.cipherData) {
          return new H.CipherData(a.cipherData, a.type)
        }
        switch(a.type) {
          case 1:
            b = !0;
            break;
          case 2:
            b = !1;
            break;
          case 3:
            b = a.i32Data;
            break;
          case 4:
            b = a.i64Data;
            break;
          case 5:
            b = a.doubleData;
            break;
          case 6:
            b = a.stringData;
            break;
          case 7:
            b = a.binaryData;
            break;
          case 8:
          ;
          case 9:
            b = JSON.parse(a.stringData)
        }
      }
      return b
    };
    a.toTData = function(a) {
      var b = new c.TData, e = g[typeof a];
      if(e && e(b, a)) {
        return b
      }
      throw Error("Unsupported data type: " + Object.prototype.toString.call(a));
    };
    return a
  }();
  var T = function() {
    function a(a, c, g, f) {
      this.channelSerial = a;
      this.timestamp = c;
      this.name = g;
      this.data = f
    }
    var c = ("object" == typeof w ? w : require("../nodejs/lib/protocol/clientmessage_types")).TData;
    a.encrypt = function(a, e) {
      var g = new c, f = a.data;
      g.cipherData = e.encrypt(H.Data.asPlaintext(f));
      g.type = f.type;
      a.data = g
    };
    a.decrypt = function(a, c) {
      var g = a.data;
      g.cipherData && (a.data = H.Data.fromPlaintext(c.decrypt(g.cipherData), g.type))
    };
    return a
  }(), ha = function() {
    return function(a, c, b) {
      this.clientId = a;
      this.clientData = c;
      this.memberId = b
    }
  }();
  this.Serialize = function() {
    function a() {
    }
    var c = "object" == typeof w ? w : require("../nodejs/lib/protocol/clientmessage_types"), b = a.TData = {}, e = a.TMessage = {}, g = a.TPresence = {}, f = a.TProtocolMessage = {}, d = a.TMessageArray = {}, h = a.TMessageBundle = {}, m = c.TType.BUFFER;
    c.TError.prototype.toString = function() {
      var a = "[" + this.constructor.name;
      this.message && (a += ": " + this.message);
      this.statusCode && (a += "; statusCode\x3d" + this.statusCode);
      this.code && (a += "; code\x3d" + this.code);
      return a + "]"
    };
    c.TMessage.prototype.toJSON = function() {
      var a = this.data, b = {name:this.name, clientId:this.clientId, timestamp:this.timestamp, tags:this.tags}, c;
      (c = Data.isCipherData(a)) ? (b.encoding = "cipher+base64", c = H.Data.asBase64(c), b.type = a.type) : (c = Data.fromTData(a), a.type == m && (b.encoding = "base64", c = c.toString("base64")));
      b.data = c;
      return b
    };
    c.TPresence.prototype.toJSON = function() {
      var a = this.clientData, b = {name:this.name, clientId:this.clientId, memberId:this.memberId, timestamp:this.timestamp, state:this.state, tags:this.tags}, c = Data.fromTData(a);
      a && a.type == m && (b.encoding = "base64", c = c.toString("base64"));
      b.clientData = c;
      return b
    };
    b.fromREST = function(a, b) {
      var e;
      switch(a.encoding) {
        case "cipher+base64":
          e = new c.TData;
          e.type = a.type;
          e.cipherData = H.Data.fromBase64(b);
          break;
        case "base64":
          e = new c.TData;
          e.type = m;
          e.binaryData = new A(b, "base64");
          break;
        default:
          e = Data.toTData(b)
      }
      return e
    };
    e.fromJSON = function(a) {
      a.data = b.fromREST(a, a.data);
      return new c.TMessage(a)
    };
    g.fromJSON = function(a) {
      a.clientData = b.fromREST(a, a.clientData);
      return new c.TPresence(a)
    };
    f.fromJSON = function(a) {
      var b;
      if(b = a.messages) {
        for(var f = b.length, d = a.messages = Array(f), h = 0;h < f;h++) {
          d[h] = e.fromJSON(b[h])
        }
      }
      if(b = a.presence) {
        f = b.length;
        d = a.presence = Array(f);
        for(h = 0;h < f;h++) {
          d[h] = g.fromJSON(b[h])
        }
      }
      return new c.TProtocolMessage(a)
    };
    f.decode = function(a, b) {
      var e, g;
      if(b) {
        if(g = ThriftUtil.decodeSync(e = new c.TProtocolMessage, a)) {
          throw g;
        }
      }else {
        e = f.fromJSON(JSON.parse(a))
      }
      return e
    };
    h.decode = function(a, b) {
      var e = null;
      if(a) {
        if(b) {
          var g;
          if(e = ThriftUtil.decodeSync(g = new c.TMessageBundle, a)) {
            throw e;
          }
          e = g.items
        }else {
          g = JSON.parse(a);
          for(var d = g.length, e = Array(d), h = 0;h < d;h++) {
            e[h] = f.fromJSON(g[h])
          }
        }
      }
      return e
    };
    f.encode = function(a, b) {
      return b ? ThriftUtil.encodeSync(a) : JSON.stringify(a)
    };
    h.encode = function(a, b) {
      return b ? ThriftUtil.encodeSync(new c.TMessageBundle({items:a})) : JSON.stringify(a)
    };
    d.encode = function(a, b) {
      return b ? ThriftUtil.encodeSync(new c.TMessageArray({items:a.map(e.fromJSON)})) : JSON.stringify(a)
    };
    d.decode = function(a, b) {
      var f = null;
      if(a) {
        if(b) {
          var g;
          if(f = ThriftUtil.decodeSync(g = new c.TMessageArray, a)) {
            throw f;
          }
          f = g.items
        }else {
          g = JSON.parse(a);
          for(var d = g.length, f = Array(d), h = 0;h < d;h++) {
            f[h] = e.fromJSON(g[h])
          }
        }
      }
      return f
    };
    return a
  }();
  var U = function() {
    function a() {
    }
    function c(a, c, g, f, d) {
      Http.supportsAuthHeaders ? a.auth.getAuthHeaders(function(a, b) {
        a ? f(a) : d(k.mixin(b, c), g)
      }) : a.auth.getAuthParams(function(a, b) {
        a ? f(a) : d(c, k.mixin(b, g))
      })
    }
    a.get = function(a, e, g, f, d) {
      function h(m, q) {
        Http.get(a, e, m, q, function(e, m, q) {
          e && 40140 == e.code ? a.auth.authorise({force:!0}, null, function(e) {
            e ? d(e) : c(a, g, f, d, h)
          }) : d(e, m, q)
        })
      }
      c(a, g, f, d, h)
    };
    a.post = function(a, e, g, f, d, h) {
      function m(q, k) {
        Http.post(a, e, q, g, k, function(e, g, q) {
          e && 40140 == e.code ? a.auth.authorise({force:!0}, null, function(e) {
            e ? h(e) : c(a, f, d, h, m)
          }) : h(e, g, q)
        })
      }
      c(a, f, d, h, m)
    };
    return a
  }(), ja = function() {
    function a(a, b, e, g, f) {
      this.rest = a;
      this.path = b;
      this.headers = e;
      this.params = g;
      this.bodyHandler = f;
      this.basePath = b.substr(0, b.lastIndexOf("/") + 1);
      this.current = null
    }
    a.prototype.get = function(a) {
      var b = this;
      U.get(this.rest, this.path, this.headers, this.params, function(e, g, f) {
        if(e) {
          h.logAction(h.LOG_ERROR, "PaginatedResource.get()", "Unexpected error getting resource: err \x3d " + e)
        }else {
          e = b.current = b.bodyHandler(g);
          var d, n;
          if(f && (d = f.Link || f.link)) {
            n = b.parseRelLinks(d.split(","))
          }
          a(null, e, n)
        }
      })
    };
    a.prototype.parseRelLinks = function(a) {
      for(var b = {}, e = 0;e < a.length;e++) {
        var g = a[e].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
        if(g) {
          var f = this.getRel(g[1]);
          f && (b[g[2]] = f)
        }
      }
      return b
    };
    a.prototype.getRel = function(c) {
      var b = c.match(/^\.\/(\w+)\?(.*)$/);
      if(!b) {
        return null
      }
      var e = this;
      return function(c) {
        (new a(e.rest, e.basePath + b[1], e.headers, k.parseQueryString(b[2]), e.bodyHandler)).get(c)
      }
    };
    return a
  }(), ka = function() {
    function a() {
    }
    function c(a) {
      if(!a) {
        return""
      }
      "string" == typeof a && (a = JSON.parse(a));
      var b = {}, c = k.keysArray(a, !0);
      if(!c) {
        return""
      }
      c.sort();
      for(var e = 0;e < c.length;e++) {
        b[c[e]] = a[c[e]].sort()
      }
      return JSON.stringify(b)
    }
    function b(a, b) {
      this.rest = a;
      this.tokenParams = {};
      if(b.keyValue) {
        if(!b.clientId) {
          h.logAction(h.LOG_MINOR, "Auth()", "anonymous, using basic auth");
          this.method = "basic";
          this.basicKey = d(b.key || b.keyId + ":" + b.keyValue);
          this.keyId = b.keyId;
          this.keyValue = b.keyValue;
          return
        }
        if(!f) {
          var c = "client-side token request signing not supported";
          h.logAction(h.LOG_ERROR, "Auth()", c);
          throw Error(c);
        }
      }
      this.method = "token";
      b.authToken && (this.token = {id:b.authToken});
      if(b.authCallback) {
        h.logAction(h.LOG_MINOR, "Auth()", "using token auth with authCallback")
      }else {
        if(b.authUrl) {
          h.logAction(h.LOG_MINOR, "Auth()", "using token auth with authUrl")
        }else {
          if(b.keyValue) {
            h.logAction(h.LOG_MINOR, "Auth()", "using token auth with client-side signing")
          }else {
            if(this.token) {
              h.logAction(h.LOG_MINOR, "Auth()", "using token auth with supplied token only")
            }else {
              throw c = "options must include valid authentication parameters", h.logAction(h.LOG_ERROR, "Auth()", c), Error(c);
            }
          }
        }
      }
    }
    var e = "object" == typeof window, g = e ? null : require("crypto"), f, d = void 0;
    e ? (d = Base64.encode, window.CryptoJS && (CryptoJS.HmacSHA256 && CryptoJS.enc.Base64) && (f = function(a, b) {
      return CryptoJS.HmacSHA256(a, b).toString(CryptoJS.enc.Base64)
    })) : (d = function(a) {
      return(new A(a, "ascii")).toString("base64")
    }, f = function(a, b) {
      var c = g.createHmac("SHA256", b);
      c.update(a);
      return c.digest("base64")
    });
    b.prototype.authorise = function(a, b, c) {
      var e = this.token;
      if(e) {
        if(void 0 === e.expires || e.expires > this.getTimestamp()) {
          if(!a || !a.force) {
            h.logAction(h.LOG_MINOR, "Auth.getToken()", "using cached token; expires \x3d " + e.expires);
            c(null, e);
            return
          }
        }else {
          h.logAction(h.LOG_MINOR, "Auth.getToken()", "deleting expired token"), this.token = null
        }
      }
      var f = this;
      this.requestToken(a, b, function(a, b) {
        a ? c(a) : c(null, f.token = b)
      })
    };
    b.prototype.requestToken = function(b, e, f) {
      "function" == typeof b && !f ? (f = b, b = e = null) : "function" == typeof e && !f && (f = e, e = b, b = null);
      b = k.mixin(k.copy(this.rest.options), b);
      e = e || k.copy(this.tokenParams);
      f = f || a;
      var g, d = this.rest;
      if(b.authCallback) {
        h.logAction(h.LOG_MINOR, "Auth.requestToken()", "using token auth with auth_callback"), g = b.authCallback
      }else {
        if(b.authUrl) {
          h.logAction(h.LOG_MINOR, "Auth.requestToken()", "using token auth with auth_url"), g = function(a, c) {
            var e = k.mixin({accept:"application/json"}, b.authHeaders);
            Http.getUri(d, b.authUrl, e || {}, k.mixin(a, b.authParams), c)
          }
        }else {
          if(b.keyValue) {
            var t = this;
            h.logAction(h.LOG_MINOR, "Auth.requestToken()", "using token auth with client-side signing");
            g = function(a, c) {
              t.createTokenRequest(b, a, c)
            }
          }else {
            throw Error("Auth.requestToken(): authOptions must include valid authentication parameters");
          }
        }
      }
      "capability" in e && (e.capability = c(e.capability));
      var d = this.rest, l = function(a, c) {
        var e, f = function(b) {
          return d.baseUri(b) + "/keys/" + a.id + "/requestToken"
        };
        Http.post ? (e = k.defaultPostHeaders(), b.requestHeaders && k.mixin(e, b.requestHeaders), Http.post(d, f, e, a, null, c)) : (e = k.defaultGetHeaders(), b.requestHeaders && k.mixin(e, b.requestHeaders), Http.get(d, f, e, a, c))
      };
      g(e, function(a, b) {
        a ? (h.logAction(h.LOG_ERROR, "Auth.requestToken()", "token request signing call returned error; err \x3d " + a), "code" in a || (a.code = 40170), "statusCode" in a || (a.statusCode = 401), f(a)) : "issued_at" in b ? f(null, b) : l(b, function(a, b) {
          a ? (h.logAction(h.LOG_ERROR, "Auth.requestToken()", "token request API call returned error; err \x3d " + a), f(a)) : ("string" === typeof b && (b = JSON.parse(b)), h.logAction(h.LOG_MINOR, "Auth.getToken()", "token received"), f(null, b.access_token))
        })
      })
    };
    b.prototype.createTokenRequest = function(a, b, c) {
      a = a || this.rest.options;
      b = b || k.copy(this.tokenParams);
      var e = a.keyId, g = a.keyValue;
      if(!e || !g) {
        c(Error("No key specified"))
      }else {
        var d = {id:e}, t = b.client_id || "";
        t && (d.client_id = t);
        var l = b.ttl || "";
        l && (d.ttl = l);
        var v = b.capability || "";
        v && (d.capability = v);
        var w = this.rest, r = this;
        (function(e) {
          b.timestamp ? e() : a.queryTime ? w.time(function(a, f) {
            a ? c(a) : (b.timestamp = Math.floor(f / 1E3), e())
          }) : (b.timestamp = r.getTimestamp(), e())
        })(function() {
          var a = d.nonce = b.nonce || ("000000" + Math.floor(1E16 * Math.random())).slice(-16), e = d.timestamp = b.timestamp, a = d.id + "\n" + l + "\n" + v + "\n" + t + "\n" + e + "\n" + a + "\n";
          d.mac = b.mac || f(a, g);
          h.logAction(h.LOG_MINOR, "Auth.getTokenRequest()", "generated signed request");
          c(null, d)
        })
      }
    };
    b.prototype.getAuthParams = function(a) {
      "basic" == this.method ? a(null, {key_id:this.keyId, key_value:this.keyValue}) : this.authorise(null, null, function(b, c) {
        b ? a(b) : a(null, {access_token:c.id})
      })
    };
    b.prototype.getAuthHeaders = function(a) {
      "basic" == this.method ? a(null, {authorization:"Basic " + this.basicKey}) : this.authorise(null, null, function(b, c) {
        b ? a(b) : a(null, {authorization:"Bearer " + d(c.id)})
      })
    };
    b.prototype.getTimestamp = function() {
      var a = Date.now() + (this.rest.serverTimeOffset || 0);
      return Math.floor(a / 1E3)
    };
    return b
  }(), da = function() {
    function a(a) {
      if(!a) {
        var b = "no options provided";
        h.logAction(h.LOG_ERROR, "Rest()", b);
        throw Error(b);
      }
      "string" == typeof a && (a = {key:a});
      this.options = a;
      "undefined" === typeof this.options.useTextProtocol && (this.options.useTextProtocol = "object" === typeof window ? !0 : !1);
      if(a.key) {
        b = a.key.match(/^([^:\s]+):([^:.\s]+)$/);
        if(!b) {
          throw b = "invalid key parameter", h.logAction(h.LOG_ERROR, "Rest()", b), Error(b);
        }
        a.keyId = b[1];
        a.keyValue = b[2]
      }
      a.log && h.setLog(a.log.level, a.log.handler);
      h.logAction(h.LOG_MINOR, "Rest()", "started");
      this.clientId = a.clientId;
      "object" == typeof window && ("https:" == window.location.protocol && !("tls" in a)) && (a.tls = !0);
      this.serverTimeOffset = null;
      this.baseUri = this.authority = function(b) {
        return"https://" + b + ":" + (a.tlsPort || v.TLS_PORT)
      };
      this.auth = new ka(this, a);
      this.channels = new c(this)
    }
    function c(a) {
      this.rest = a;
      this.attached = {}
    }
    var b = function() {
    };
    a.prototype.stats = function(a, c) {
      void 0 === c && ("function" == typeof a ? (c = a, a = null) : c = b);
      var f = k.copy(k.defaultGetHeaders());
      this.options.headers && k.mixin(f, this.options.headers);
      (new ja(this, "/stats", f, a, function(a) {
        return"string" === typeof a ? JSON.parse(a) : a
      })).get(c)
    };
    a.prototype.time = function(a, c) {
      void 0 === c && ("function" == typeof a ? (c = a, a = null) : c = b);
      var f = k.copy(k.defaultGetHeaders());
      this.options.headers && k.mixin(f, this.options.headers);
      var d = this;
      Http.get(this, function(a) {
        return d.authority(a) + "/time"
      }, f, a, function(a, b) {
        if(a) {
          c(a)
        }else {
          "string" === typeof b && (b = JSON.parse(b));
          var e = b[0];
          e ? (d.serverTimeOffset = e - Date.now(), c(null, e)) : (a = Error("Internal error (unexpected result type from GET /time)"), a.statusCode = 500, c(a))
        }
      })
    };
    c.prototype.get = function(a) {
      a = String(a);
      var b = this.attached[a];
      b || (this.attached[a] = b = new ca(this.rest, a));
      return b
    };
    return a
  }(), I = function() {
    function a(a) {
      h.logAction(h.LOG_MINOR, "Realtime()", "");
      da.call(this, a);
      this.connection = new la(this, a);
      this.channels = new c(this);
      this.connection.connect()
    }
    function c(a) {
      this.realtime = a;
      this.attached = {};
      var c = this;
      a.connection.connectionManager.on("transport.active", function(a) {
        c.onTransportActive(a)
      })
    }
    k.inherits(a, da);
    a.prototype.close = function() {
      h.logAction(h.LOG_MINOR, "Realtime.close()", "");
      this.connection.close()
    };
    c.prototype.onChannelMessage = function(a) {
      var c = a.channel;
      if(c) {
        var d = this.attached[c];
        if(d) {
          d.onMessage(a)
        }else {
          h.logAction(h.LOG_ERROR, "ConnectionManager on(channelmessage)", "received event for non-existent channel: " + c)
        }
      }else {
        h.logAction(h.LOG_ERROR, "ConnectionManager on(channelmessage)", "received event unspecified channel: " + c)
      }
    };
    c.prototype.onTransportActive = function() {
      for(var a in this.attached) {
        var c = this.attached[a];
        "attaching" == c.state ? c.attachImpl() : "detaching" == c.state && c.detachImpl()
      }
    };
    c.prototype.setSuspended = function(a) {
      for(var c in this.attached) {
        this.attached[c].setSuspended(a)
      }
    };
    c.prototype.get = function(a) {
      a = String(a);
      var c = this.attached[a];
      c || (this.attached[a] = c = new fa(this.realtime, a, this.realtime.options));
      return c
    };
    return a
  }(), ba = function() {
    return function(a, c, b, e) {
      this.previous = a;
      this.current = c;
      b && (this.retryIn = b);
      e && (this.reason = e)
    }
  }(), la = function() {
    function a(a, b) {
      r.call(this);
      this.ably = a;
      this.connectionManager = new y(a, b);
      this.state = this.connectionManager.state.state;
      this.id = void 0;
      var e = this;
      this.connectionManager.on("connectionstate", function(a) {
        var b = e.state = a.current;
        k.nextTick(function() {
          e.emit(b, a)
        })
      })
    }
    k.inherits(a, r);
    a.prototype.on = function(a, b) {
      r.prototype.on.apply(this, arguments);
      if(this.state == a && b) {
        try {
          b(new ba(void 0, a))
        }catch(e) {
        }
      }
    };
    a.prototype.connect = function() {
      this.connectionManager.requestState({state:"connecting"})
    };
    a.prototype.close = function() {
      this.connectionManager.requestState({state:"closed"})
    };
    return a
  }(), ca = function() {
    function a() {
    }
    function c(a, c, f) {
      h.logAction(h.LOG_MINOR, "Channel()", "started; name \x3d " + c);
      r.call(this);
      this.rest = a;
      this.name = c;
      this.basePath = "/channels/" + encodeURIComponent(c);
      this.cipher = null;
      this.presence = new b(this)
    }
    function b(a) {
      this.channel = a;
      this.basePath = a.basePath + "/presence"
    }
    k.inherits(c, r);
    c.prototype.setOptions = function(b, c) {
      c = c || a;
      if(b && b.encrypted) {
        var f = this;
        H.getCipher(b, function(a, b) {
          f.cipher = b;
          c(null)
        })
      }else {
        c(null, this.cipher = null)
      }
    };
    c.prototype.history = function(b, c) {
      h.logAction(h.LOG_MICRO, "Channel.history()", "channel \x3d " + this.name);
      void 0 === c && ("function" == typeof b ? (c = b, b = null) : c = a);
      var f = this.rest, d = !f.options.useTextProtocol, n = k.copy(k.defaultGetHeaders(d)), m = this.cipher;
      f.options.headers && k.mixin(n, f.options.headers);
      U.get(f, this.basePath + "/messages", n, b, function(a, b) {
        if(a) {
          c(a)
        }else {
          try {
            for(var f = Serialize.TMessageArray.decode(b, d), e = 0;e < f.length;e++) {
              m && T.decrypt(f[e], m), f[e].data = Data.fromTData(f[e].data)
            }
            c(null, f)
          }catch(h) {
            c(h)
          }
        }
      })
    };
    c.prototype.publish = function(b, c, f) {
      h.logAction(h.LOG_MICRO, "Channel.publish()", "channel \x3d " + this.name + "; name \x3d " + b);
      f = f || a;
      var d = this.rest, n = !d.options.useTextProtocol;
      b = {name:b, data:c};
      (c = this.cipher) && T.encrypt(b, c);
      b = Serialize.TMessageArray.encode([b], n);
      n = k.copy(k.defaultPostHeaders(n));
      d.options.headers && k.mixin(n, d.options.headers);
      U.post(d, this.basePath + "/messages", b, n, null, f)
    };
    b.prototype.get = function(b, c) {
      h.logAction(h.LOG_MICRO, "Channel.presence.get()", "channel \x3d " + this.channel.name);
      void 0 === c && ("function" == typeof b ? (c = b, b = null) : c = a);
      var f = this.channel.rest, d = !f.options.useTextProtocol, n = k.copy(k.defaultGetHeaders(d));
      f.options.headers && k.mixin(n, f.options.headers);
      U.get(f, this.basePath, n, b, function(a, b) {
        a ? c(a) : d ? ha.decodeTPresenceArray(b, c) : c(null, b)
      })
    };
    b.prototype.history = function(b, c) {
      h.logAction(h.LOG_MICRO, "Channel.presence.history()", "channel \x3d " + this.channel.name);
      void 0 === c && ("function" == typeof b ? (c = b, b = null) : c = a);
      var f = this.channel.rest, d = !f.options.useTextProtocol, n = k.copy(k.defaultGetHeaders(d));
      f.options.headers && k.mixin(n, f.options.headers);
      U.get(f, this.basePath + "/history", n, b, function(a, b) {
        if(a) {
          c(a)
        }else {
          try {
            for(var f = Serialize.TMessageArray.decode(b, d), e = 0;e < f.length;e++) {
              f[e].data = Data.fromTData(f[e].data)
            }
            c(null, f)
          }catch(h) {
            c(h)
          }
        }
      })
    };
    return c
  }(), fa = function() {
    function a(a, b, c) {
      h.logAction(h.LOG_MINOR, "RealtimeChannel()", "started; name \x3d " + b);
      ca.call(this, a, b, c);
      this.presence = new ma(this, c);
      this.connectionManager = a.connection.connectionManager;
      this.options = k.prototypicalClone(d, c);
      this.state = "initialized";
      this.subscriptions = new r;
      this.pendingEvents = []
    }
    var c = "object" == typeof w ? w : require("../nodejs/lib/protocol/clientmessage_types"), b = c.TAction, e = function() {
    }, d = {queueEvents:!0};
    k.inherits(a, ca);
    a.invalidStateError = {statusCode:400, code:90001, reason:"Channel operation failed (invalid channel state)"};
    a.channelDetachedErr = {statusCode:409, code:90006, reason:"Channel is detached"};
    a.prototype.setOptions = function(a, b) {
      b = b || e;
      if(a && a.encrypted) {
        var c = this;
        H.getCipher(a, function(a, f) {
          c.cipher = f;
          b(null)
        })
      }else {
        b(null, this.cipher = null)
      }
    };
    a.prototype.publish = function() {
      var a = this.connectionManager;
      if(y.activeState(a.state)) {
        var b = arguments.length, a = arguments[0], d = arguments[b - 1];
        "function" !== typeof d && (d = e, ++b);
        if(2 == b) {
          k.isArray(a) || (a = [a]);
          for(var g = Array(a.length), b = 0;b < a.length;b++) {
            var h = a[b], l = g[b] = new c.TMessage;
            l.name = h.name;
            l.data = Data.toTData(h.data)
          }
          a = g
        }else {
          h = new c.TMessage, h.name = arguments[0], h.data = Data.toTData(arguments[1]), a = [h]
        }
        if(g = this.cipher) {
          for(b = 0;b < a.length;b++) {
            T.encrypt(a[b], g)
          }
        }
        this._publish(a, d)
      }else {
        d(a.getStateError())
      }
    };
    a.prototype._publish = function(a, b) {
      h.logAction(h.LOG_MICRO, "RealtimeChannel.publish()", "message count \x3d " + a.length);
      switch(this.state) {
        case "attached":
          h.logAction(h.LOG_MICRO, "RealtimeChannel.publish()", "sending message");
          var e = new c.TProtocolMessage;
          e.action = c.TAction.MESSAGE;
          e.channel = this.name;
          e.messages = a;
          this.sendMessage(e, b);
          break;
        default:
          this.attach();
        case "attaching":
          h.logAction(h.LOG_MICRO, "RealtimeChannel.publish()", "queueing message"), this.pendingEvents.push({messages:a, callback:b})
      }
    };
    a.prototype.onEvent = function(a) {
      h.logAction(h.LOG_MICRO, "RealtimeChannel.onEvent()", "received message");
      for(var b = this.subscriptions, c = 0;c < a.length;c++) {
        var e = a[c];
        b.emit(e.name, e)
      }
    };
    a.prototype.attach = function(a) {
      a = a || e;
      var b = this.connectionManager;
      y.activeState(b.state) ? "attached" == this.state ? a() : "failed" == this.state ? a(b.getStateError()) : (this.once(function(c) {
        switch(this.event) {
          case "attached":
            a();
            break;
          case "detached":
          ;
          case "failed":
            a(c || b.getStateError())
        }
      }), this.attachImpl()) : a(b.getStateError())
    };
    a.prototype.attachImpl = function(a) {
      h.logAction(h.LOG_MICRO, "RealtimeChannel.attachImpl()", "sending ATTACH message");
      this.state = "attaching";
      var b = new c.TProtocolMessage({action:c.TAction.ATTACH, channel:this.name});
      this.sendMessage(b, a || e)
    };
    a.prototype.detach = function(b) {
      b = b || e;
      var c = this.connectionManager;
      y.activeState(c.state) ? "detached" == this.state ? b() : (this.once(function(a) {
        switch(this.event) {
          case "detached":
            b();
            break;
          case "attached":
            b(D.unknownChannelErr);
            break;
          case "failed":
            b(a || c.getStateError())
        }
      }), this.detachImpl(), this.setSuspended(a.channelDetachedErr, !0)) : b(c.getStateError())
    };
    a.prototype.detachImpl = function(a) {
      h.logAction(h.LOG_MICRO, "RealtimeChannel.detach()", "sending DETACH message");
      this.state = "detaching";
      var b = new c.TProtocolMessage({action:c.TAction.DETACH, channel:this.name});
      this.sendMessage(b, a || e)
    };
    a.prototype.subscribe = function() {
      var a = Array.prototype.slice.call(arguments);
      1 == a.length && "function" == typeof a[0] && a.unshift(null);
      var b = a[0], c = a[1], a = a[2] = a[2] || e, d = this.subscriptions;
      if(null === b || !k.isArray(b)) {
        d.on(b, c)
      }else {
        for(var g = 0;g < b.length;g++) {
          d.on(b[g], c)
        }
      }
      this.attach(a)
    };
    a.prototype.unsubscribe = function() {
      var a = Array.prototype.slice.call(arguments);
      1 == a.length && "function" == typeof a[0] && a.unshift(null);
      var b = a[0], a = a[1], c = this.subscriptions;
      if(null === b || !k.isArray(b)) {
        c.off(b, a)
      }else {
        for(var e = 0;e < b.length;e++) {
          c.off(b[e], a)
        }
      }
    };
    a.prototype.sendMessage = function(a, b) {
      this.connectionManager.send(a, this.options.queueEvents, b)
    };
    a.prototype.sendPresence = function(a, b) {
      var e = new c.TProtocolMessage({action:c.TAction.PRESENCE, channel:this.name, presence:[a]});
      this.sendMessage(e, b)
    };
    a.prototype.onMessage = function(a) {
      switch(a.action) {
        case b.ATTACHED:
          this.setAttached(a);
          break;
        case b.DETACHED:
          this.setDetached(a);
          break;
        case b.PRESENCE:
          this.presence.setPresence(a.presence, !0);
          break;
        case b.MESSAGE:
          if(a = a.messages) {
            for(var c = Array(a.length), e = this.cipher, d = 0;d < c.length;d++) {
              var g = a[d];
              if(e) {
                try {
                  T.decrypt(g, e)
                }catch(l) {
                  var k = "Unexpected error decrypting message; err \x3d " + l;
                  h.logAction(h.LOG_ERROR, "RealtimeChannel.onMessage()", k);
                  this.emit("error", Error(k))
                }
              }
              c[d] = new T(g.channelSerial, g.timestamp, g.name, Data.fromTData(g.data))
            }
            this.onEvent(c)
          }
          break;
        case b.ERROR:
          this.setDetached(a);
          break;
        default:
          h.logAction(h.LOG_ERROR, "RealtimeChannel.onMessage()", "Fatal protocol error: unrecognised action (" + a.action + ")"), this.connectionManager.abort(D.unknownChannelErr)
      }
    };
    a.mergeTo = function(a, c) {
      var e = !1, d;
      if(a.channel == c.channel && (d = a.action) == c.action) {
        switch(d) {
          case b.MESSAGE:
            for(e = 0;e < c.messages.length;e++) {
              a.messages.push(c.messages[e])
            }
            e = !0;
            break;
          case b.PRESENCE:
            for(e = 0;e < c.presence.length;e++) {
              a.presence.push(c.presence[e])
            }
            e = !0
        }
      }
      return e
    };
    a.prototype.setAttached = function(a) {
      h.logAction(h.LOG_MINOR, "RealtimeChannel.setAttached", "activating channel; name \x3d " + this.name);
      a.presence && this.presence.setPresence(a.presence, !1);
      if("attaching" == this.state) {
        this.state = "attached";
        try {
          if(this.pendingEvents.length) {
            var b = new c.TProtocolMessage({action:c.TAction.MESSAGE, channel:this.name, messages:[]}), e = new aa;
            h.logAction(h.LOG_MICRO, "RealtimeChannel.setAttached", "sending " + this.pendingEvents.length + " queued messages");
            for(a = 0;a < this.pendingEvents.length;a++) {
              var d = this.pendingEvents[a];
              Array.prototype.push.apply(b.messages, d.messages);
              e.push(d.callback)
            }
            this.sendMessage(b, e)
          }
          this.presence.setAttached()
        }catch(g) {
          h.logAction(h.LOG_ERROR, "RealtimeChannel.setAttached()", "Unexpected exception sending pending messages: " + g.stack)
        }
        this.emit("attached")
      }
    };
    a.prototype.setDetached = function(a) {
      (a = a.error) ? (this.state = "failed", this.emit("failed", {statusCode:a.statusCode, code:a.code, reason:a.reason})) : "detached" !== this.state && (this.state = "detached", this.emit("detached"))
    };
    a.prototype.setSuspended = function(a, b) {
      h.logAction(h.LOG_MINOR, "RealtimeChannel.setSuspended", "deactivating channel; name \x3d " + this.name + ", err " + (a ? a.reason : "none"));
      for(var c = 0;c < this.pendingEvents.length;c++) {
        try {
          this.pendingEvents[c].callback(a)
        }catch(e) {
        }
      }
      this.pendingEvents = [];
      this.presence.setSuspended(a);
      b || this.emit("detached")
    };
    return a
  }(), ma = function() {
    function a(a, b) {
      r.call(this);
      this.channel = a;
      this.clientId = b.clientId;
      this.members = {}
    }
    var c = "object" == typeof w ? w : require("../nodejs/lib/protocol/clientmessage_types"), b = c.TPresenceState, e = ["enter", "leave", "update"];
    k.inherits(a, r);
    a.prototype.enter = function(a, b) {
      !b && "function" === typeof a && (b = a, a = "");
      if(!this.clientId) {
        throw Error("clientId must be specified to enter a presence channel");
      }
      this.enterClient(this.clientId, a, b)
    };
    a.prototype.enterClient = function(a, e, d) {
      h.logAction(h.LOG_MICRO, "Presence.enterClient()", "entering; channel \x3d " + this.channel.name + ", client \x3d " + a);
      a = new c.TPresence({state:b.ENTER, clientId:a, clientData:Data.toTData(e)});
      e = this.channel;
      switch(e.state) {
        case "attached":
          e.sendPresence(a, d);
          break;
        case "initialized":
          e.attach();
        case "attaching":
          this.pendingPresence = {presence:a, callback:d};
          break;
        default:
          a = Error("Unable to enter presence channel (incompatible state)"), a.code = 90001, d(a)
      }
    };
    a.prototype.leave = function(a) {
      if(!this.clientId) {
        throw Error("clientId must have been specified to enter or leave a presence channel");
      }
      this.leaveClient(this.clientId, a)
    };
    a.prototype.leaveClient = function(a, e) {
      h.logAction(h.LOG_MICRO, "Presence.leaveClient()", "leaving; channel \x3d " + this.channel.name + ", client \x3d " + a);
      var d = new c.TPresence({state:b.LEAVE, clientId:a}), n = this.channel;
      switch(n.state) {
        case "attached":
          n.sendPresence(d, e);
          break;
        case "attaching":
          this.pendingPresence = {presence:d, callback:e};
          break;
        case "initialized":
          this.pendingPresence = null;
          d = Error("Unable to enter presence channel (incompatible state)");
          d.code = 90001;
          e(d);
          break;
        default:
          this.pendingPresence = null, e(D.failed)
      }
    };
    a.prototype.get = function(a) {
      return a ? this.members[a] : k.valuesArray(this.members, !0)
    };
    a.prototype.setPresence = function(a, c) {
      h.logAction(h.LOG_MICRO, "Presence.setPresence()", "received presence for " + a.length + " participants");
      for(var d = 0;d < a.length;d++) {
        var n = a[d], m = n.clientId + ":" + n.memberId, q = new ha(n.clientId, Data.fromTData(n.clientData), n.memberId);
        switch(n.state) {
          case b.LEAVE:
            delete this.members[m];
            break;
          case b.UPDATE:
            n.inheritMemberId && delete this.members[n.clientId + ":" + n.inheritMemberId];
          case b.ENTER:
            clientData = this.members[m] = q
        }
        c && this.emit(e[n.state], q)
      }
    };
    a.prototype.setAttached = function() {
      this.pendingPresence && (h.logAction(h.LOG_MICRO, "Presence.setAttached", "sending queued presence; state \x3d " + this.state), this.channel.sendPresence(this.pendingPresence.presence, this.pendingPresence.callback), this.pendingPresence = null)
    };
    a.prototype.setSuspended = function(a) {
      this.pendingPresence && (this.pendingPresence.callback(a), this.pendingPresence = null)
    };
    return a
  }();
  (function() {
    function a(a, b, c) {
      c.binary = !1;
      O.call(this, a, b, c)
    }
    var c = function() {
    }, b = window.Ably._ = function(a) {
      return b[a] || c
    }, e = 1;
    k.inherits(a, O);
    a.isAvailable = function() {
      return!0
    };
    y.httpTransports.jsonp = y.transports.jsonp = a;
    var d = null;
    a.checkConnectivity = function(b) {
      d ? d.push(b) : (d = [b], (new a.Request(0)).send("http://internet-up.ably.io.s3-website-us-east-1.amazonaws.com/is-the-internet-up.js", null, null, null, !1, !1, function(a, b) {
        for(var c = !a && b, e = 0;e < d.length;e++) {
          d[e](null, c)
        }
        d = null
      }))
    };
    a.tryConnect = function(b, c, e, d) {
      var g = new a(b, c, e), k = function(a) {
        d(a)
      };
      g.on("error", k);
      g.on("preconnect", function() {
        h.logAction(h.LOG_MINOR, "JSONPTransport.tryConnect()", "viable transport " + g);
        g.off("error", k);
        d(null, g)
      });
      g.connect()
    };
    a.prototype.toString = function() {
      return"JSONPTransport; uri\x3d" + this.baseUri + "; isConnected\x3d" + this.isConnected
    };
    a.prototype.request = function(b, c, e, d, g) {
      var h = new a.Request;
      h.send(b, c, null, e, d, !1, g);
      return h
    };
    a.Request = function(a) {
      this.requestId = a || e++
    };
    a.Request.prototype.send = function(a, c, e, d, g, h, k) {
      this.callback = k;
      var l = this.requestId, w = this.timer = setTimeout(function() {
        x.abort()
      }, g ? v.cometRecvTimeout : v.cometSendTimeout);
      c = c || {};
      c.callback = "Ably._(" + l + ")";
      d ? c.body = encodeURIComponent(d) : delete c.body;
      var r = document.createElement("script");
      r.async = !0;
      r.onerror = function(a) {
        x.abort()
      };
      r.src = O.paramStr(c, a);
      var x = this, y = this._finish = function() {
        clearTimeout(w);
        r.parentNode && r.parentNode.removeChild(r);
        delete b[l]
      };
      b[l] = function(a) {
        y();
        x.aborted || k(null, a)
      };
      a = document.getElementsByTagName("script")[0];
      a.parentNode.insertBefore(r, a)
    };
    a.Request.prototype.abort = function() {
      this.aborted = !0;
      this._finish();
      this.callback(Error("JSONPTransport: requestId " + this.requestId + " aborted"))
    };
    Http.Request = function(b, c, e, d, g, h) {
      (new a.Request).send(b, c, e, d, !1, g, h)
    };
    return a
  })();
  (function() {
    function a(b, c, d) {
      d.binary = d.binary && a.binary;
      O.call(this, b, c, d)
    }
    var c = function() {
      var a = new XMLHttpRequest;
      return"withCredentials" in a ? a : "undefined" !== typeof XDomainRequest ? new XDomainRequest : null
    };
    k.inherits(a, O);
    a.isAvailable = function() {
      if(!c()) {
        return!1
      }
      a.binary = !1;
      return!0
    };
    a.checkConnectivity = function(b) {
      (new a.Request).send("http://internet-up.ably.io.s3-website-us-east-1.amazonaws.com/is-the-internet-up.txt", null, null, null, !1, !1, function(a, c) {
        b(null, !a && "yes" == c)
      })
    };
    a.tryConnect = function(b, c, d, f) {
      var k = new a(b, c, d), n = function(a) {
        f(a)
      };
      k.on("error", n);
      k.on("preconnect", function() {
        h.logAction(h.LOG_MINOR, "XHRTransport.tryConnect()", "viable transport " + k);
        k.off("error", n);
        f(null, k)
      });
      k.connect()
    };
    a.prototype.request = function(b, c, d, f, h) {
      var k = new a.Request;
      k.send(b, c, null, d, f, this.binary, h);
      return k
    };
    a.prototype.toString = function() {
      return"XHRTransport; uri\x3d" + this.baseUri + "; isConnected\x3d" + this.isConnected
    };
    a.Request = function() {
    };
    a.Request.prototype.send = function(a, e, d, f, h, k, l) {
      d = d || {};
      a = O.paramStr(e, a);
      var q, r, w;
      f ? (e = "POST", q = 201) : (e = "GET", q = 200);
      var u = this.xhr = c();
      k && (u.responseType = "arraybuffer", f && (f = f.view));
      var x = setTimeout(function() {
        w = !0;
        u.abort()
      }, h ? v.cometRecvTimeout : v.cometSendTimeout);
      u.open(e, a, !0);
      f && (!k && "object" === typeof f) && (d["content-type"] || (d["content-type"] = "application/json"), f = JSON.stringify(f));
      d.accept || (d.accept = k ? "application/x-thrift" : "application/json");
      for(var y in d) {
        u.setRequestHeader(y, d[y])
      }
      u.onerror = function(a) {
        a.code = 8E4;
        l(a)
      };
      u.onabort = function() {
        r = Error(w ? "Request timed out" : "Request cancelled");
        r.statusCode = 404;
        r.code = 8E4;
        l(r)
      };
      u.onreadystatechange = function() {
        if(4 == u.readyState) {
          if(clearTimeout(x), r) {
            l(r)
          }else {
            if(u.status == q) {
              var a = null;
              k ? u.response && (a = new A, a.buf = u.response, a.view = new DataView(a.buf)) : a = u.responseText;
              for(var b = u.getAllResponseHeaders().trim().split("\n"), c = {}, e = 0;e < b.length;e++) {
                var d = b[e].split(":");
                c[d[0].trim()] = d[1].trim()
              }
              l(null, a, c)
            }else {
              0 != u.status && (r = Error("Unexpected response: statusCode \x3d " + u.status), r.statusCode = u.status, r.code = 8E4, r.statusText = u.statusText, l(r))
            }
          }
        }
      };
      u.send(f)
    };
    a.Request.prototype.abort = function() {
      this.xhr && this.xhr.abort()
    };
    a.isAvailable() && (y.httpTransports.xhr = y.transports.xhr = a, Http.supportsAuthHeaders = !0, Http.Request = function(b, c, d, f, h, k) {
      (new a.Request).send(b, c, d, f, !1, h, k)
    });
    return a
  })();
  (function() {
    function a(a, c, d) {
      d.binary = !1;
      ga.call(this, a, c, d)
    }
    var c = "object" == typeof window;
    k.inherits(a, ga);
    a.isAvailable = function() {
      return c && S && 10 <= S.getFlashPlayerVersion().major && $
    };
    a.isAvailable() && (y.transports.flash_socket = a);
    a.tryConnect = function(b, c, d, f) {
      $.__initialize(b.options.flashTransport && b.options.flashTransport.swfLocation || v.flashTransport.swfLocation);
      var k = new a(b, c, d), l = function(a) {
        f(a)
      };
      k.on("wserror", l);
      k.on("wsopen", function() {
        h.logAction(h.LOG_MINOR, "FlashTransport.tryConnect()", "viable transport " + k);
        k.off("wserror", l);
        f(null, k)
      });
      k.connect()
    };
    a.prototype.createWebSocket = function(a, c) {
      var d = 0;
      if(c) {
        for(var f in c) {
          a += (d++ ? "\x26" : "?") + f + "\x3d" + c[f]
        }
      }
      this.uri = a;
      d = this.params.options;
      return new $(a, [], d.proxyHost, d.proxyPort)
    };
    a.prototype.toString = function() {
      return"FlashTransport; uri\x3d" + this.uri
    };
    return a
  })();
  window.Ably.Realtime = I;
  I.Crypto = H;
  da.Crypto = H
})();
